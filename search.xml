<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[语言类型]]></title>
    <url>%2F2019%2F10%2F03%2F%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[编程语言分为动态/静态类型、强/弱类型两种概念。 动态类型和静态类型动态类型和静态类型的主要区别在于数据类型检查的时机。 动态类型运行期间才会做数据类型检查。 在用动态类型语言编程时，不需要提前给变量等指定类型，该类型语言会在第一次赋值给变量时，在内部将数据类型记录下来。 常见语言： Python、Ruby、PHP、JS、VBScript 静态类型编译时做数据类型检查。 在用静态类型语言编程时，需要在使用变量之前就给变量指定类型，数据类型是固定不可变的。 静态类型可以分为两种： 如果类型是语言语法的一部分，在是explicitly typed显式类型； 如果类型通过编译时推导，是implicity typed**隐式类型**, 比如ML和Haskell 常见语言： C、C++、C#、Java、TS、Go 对比 动态类型不便于调试，命名不规范会造成阅读困难，不易联合开发、维护。但不需要写太多类型相关代码。 静态类型结构规范，便于调试，更加安全。但关于类型声明代码较多，不易阅读。 强类型和弱类型强类型和弱类型的主要区别在于变量类型是否固定。 强类型变量一旦定义数据类型，如果不进行强制转换，就永远不变，不允许隐式转换。 类型安全。 常见语言： C、C++、C#、Java、TS、Go 弱类型数据类型可以被忽略。一个变量可以赋值多个类型的值，允许隐式转换。 类型不安全。 常见语言： Python、Ruby、PHP、JS、VBScript、ASP 其他类型的划分，其实更严格的来说，是参照程序错误时的禁止行为判断。 Program Errors（程序错误） trapped errors：导致程序终止执行（程序意识到出错，使用对应的错误处理机制），如除 0，Java 中数组越界访问 untrapped errors：程序出错后继续执行（其实并不一定保证继续执行，程序本身并不知道出错，也没有对应的错误处理机制），如 C 语言里的缓冲区溢出，Jmp 到错误地址 Forbidden Behaviors（禁止行为） 程序在设计的时候会定义一组 forbidden behaviors，包括了所有的 untrapped errors，可能包括 trapped errors。 Well behaved、ill behaved well behaved: 如果程序的执行不可能出现 forbidden behaviors，则称为 well behaved ill behaved: 只要有可能出现 forbidden behaviors，则称为 ill behaved 从图中可以看出，绿色的 program 表示所有程序（所有程序，你能想到和不能想到的），error 表示出错的程序，error 不仅仅包括 trapped error 和 untrapped error。 根据图我们可以严格的定义动态类型，静态类型；强类型，弱类型 强类型：如果一门语言写出来的程序在红色矩形外部，则这门语言是强类型的，也就是上面说的 well behaved 弱类型：如果一门语言写出来的程序可能在红色矩形内部，则这门语言是弱类型的，也就是上面说的 ill behaved 静态类型：一门语言在编译时排除可能出现在红色矩形内的情况（通过语法报错），则这门语言是静态类型的 动态类型：一门语言在运行时排除可能出现在红色矩形内的情况（通过运行时报错，但如果是弱类型可能会触发 untrapped error，比如隐式转换，使得程序看起来似乎是正常运行的），则这门语言是动态类型的]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript从入门到放弃1]]></title>
    <url>%2F2019%2F09%2F07%2FTypeScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%831%2F</url>
    <content type="text"><![CDATA[基本概念安装1npm install -g typescript 与JS的对比 TypeScript具有类型系统，且是JavaScript的超集。 它可以编译成普通的JavaScript代码。 TypeScript支持任意浏览器，任意环境，任意系统并且是开源的。 TS 强类型语言、静态类型 类型检测 增加了代码的可读性和可维护性 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展 便于协作、开发大型项目 JS 兼容性好 弱类型语言、动态类型 脚本编写语言，无需编译，只要嵌入 HTML 代码中，就能由浏览器逐行加载解释执行。 基于对象的语言，可以创建对象同时使用现有对象。但是 Javascript 并不支持其它面向对象语言所具有的继承和重载功能。 JavaScript 是事件驱动的，只根据用户的操作做出相应的反应处理。 只依赖于浏览器，与操作系统的因素无关 数据类型TypeScript 中，使用 : 指定变量的类型，: 的前后有没有空格都可以。 string：字符串 number：数字 boolean：布尔 array：数组 tuple:元组 enum：枚举 ​ 随着计算机的不断普及，程序不仅只用于数值计算，还更广泛地用于处理非数值的数据。 ​ 例如：性别、月份、星期几、颜色、单位名、学历、职业等，都不是数值数据。 ​ 在其它程序设计语言中，一般用一个数值来代表某一状态，这种处理方法不直观，易读性差。 ​ 如果能在程序中用自然语言中有相应含义的单词来代表某一状态，则程序就很容易阅读和理解。 ​ 也就是说，事先考虑到某一变量可能取的值，尽量用自然语言中含义清楚的单词来表示它的每一个值， ​ 这种方法称为枚举方法，用这种方法定义的类型称枚举类型。 ​ 1234567enum 枚举名&#123; 标识符[=整型常量]&#125;enum Flag &#123;success = 1, error = 0&#125;;let s: Flag = Flag.errorconsole.log(s) //0 void： ​ any：任意类型 null undefined never]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入了解对象]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[对象概念对象是 JavaScript 中最重要的数据结构之一。 从根本上来说，对象就是一个有关联的键/值对的集合。我们使用大括号（即 { 和 }）来创建对象。 数组 中的元素被数字索引所引用，而_对象_中的键则必须直接命名。 对象是无序集合。 运作方式： 12345const car = &#123; color: 'red', year: 1992, isPreOwned: true&#125;; 赋给该对象的变量被命名为 car。 使用大括号来定义 car 对象。 每个键（例如 color）均与一个值（在此处为 &#39;red&#39;）相关联。这些键值对通过冒号 (:) 连接起来。 每个独特的键值对（称为该对象的属性）均通过逗号 (,) 与其他属性分隔开来。因此，car 对象包含三个属性。 键（即对象属性的_名称）是字符串，但是围绕这些字符串的引号是可选的_，前提是该字符串也是一个有效的 JavaScript 标识符（即可以将其用作变量名称或函数名称） 在某些情况下_需要_包含引号，特别是如果属性名称： 是保留字（例如 for、if、let、true 等）。 包含不能出现在变量名称中的空格或特殊字符（即 $ 和 _ 以外的标点符号，包括大多数重音字符）。 与Ruby哈希的区别Ruby 哈希和 JavaScript 对象具有相似的功能：它们都是可以被键访问的值集合，但是，Ruby 哈希中访问值的方式略有不同。请考虑以下 Ruby 哈希： 12345book = &#123; title: 'To Kill a Mockingbird', author: 'Harper Lee', published: 1960&#125; 由于哈希键是符号，因此属性被该符号所访问： 123book[:title]# 'To Kill a Mockingbird' 任何使用 JavaScript 点表示法或方括号表示法的尝试都会导致不良结果： 123book.title# undefined method `title' for #&lt;Hash&gt; (NoMethodError) 123book['title']# nil Ruby 哈希和 JavaScript 对象之间的另一个重要区别是，对象可以将一个函数作为属性值，而Ruby 哈希不行。 与python字典的区别Python 字典中的键必须是可哈希的（例如字符串、数字、浮点数等）。 以下是 JavaScript 中的一个有效对象： 1234const javascriptObject = &#123; name: 'George Orwell', year: 1984 &#125; 然而，它作为一个 Python 字典则是无效的： 1234python_dictionary = &#123;name: 'George Orwell', year: 1984&#125;# Traceback (most recent call last):# NameError: name 'name' is not defined 一个快速对策是将 Python 字典的键转换为字符串： 1my_dictionary = &#123;'name': 'George Orwell', 'year': 1984&#125; 创建对象 字面量表示法 Object() 构造函数 虽然这两个方法最终都会返回一个没有自己属性的对象，但是 Object() 构造函数相对较慢，而且较为冗长。因此，在 JavaScript 中创建新对象的推荐方法是使用字面量表示法。 访问对象属性 点表示法 方括号表示法 尽管点表示法可能更易于读写，但它并不适用于所有情况。假设对象中有一个键是_数字_。那么，像bicycle.1; 这样的表达式将会导致错误，而bicycle[1]; 则可以返回预期的值。 删除属性 delete 运算符，会直接改变当前的对象。删除成功后会返回true。 1delete obj.name; js中原始类型（例如字符串、数字、布尔值等）是不可变的。换句话说，对函数中的参数所作的任何更改都会有效地为该函数创建一个局部_副本_，而_不会影响该函数外部_的原始类型 123456789let string = 'orange';function changeToApple(string) &#123; string = 'apple';&#125;changeToApple(string);console.log(string); //orange 全局对象只有使用 var 关键字来声明变量才会将其添加到 window 对象中。如果你用 let 或 const 在函数外部声明一个变量，它将_不会_被作为属性添加到 window 对象中。 与全局变量可以作为 window 对象上的属性进行访问类似，任何全局函数声明都可以作为 window 对象上的方法进行访问。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular1.x从入门到放弃]]></title>
    <url>%2F2019%2F08%2F01%2FAngular1.x%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%2F</url>
    <content type="text"><![CDATA[MV*对于大型体系，需要优化结构层次，将体系分层管理。 将模块和视图区分，用中间层 项目小的时候，后台语言杂糅着HTML，css也写在HTML中；（2004） 项目变大时，后台语言和HTML分开，HTML\CSS\JS分开； 项目更大时，JS拆分成各种包，使用设计模式降低耦合；（比如开发游戏：使用中介者模式，将业务拆分到不同js文件中） 项目更大时，JS采用模块化开发方式，分层开发，便于插拔。 模块化设计不是逐条编程，而是先将主程序、子程序、子过程等框架把软件的主要结构和流程描述出来，并定义好各个框架间的输入输出关系。形成以功能块为单位的算法描述。 目的： 降低程序复杂度； 使程序设计、调试、维护更简单 模块化开发有两个基本模式：AMD和CMD。Angular是典型的AMD，Node是典型的CMD。 MVC一种模块化开发思想 Model：应用程序中处理数据逻辑的部分。 View：应用程序中处理数据显示的部分。 Controller：应用程序中处理用户交互的部分。 MVC、MVVM、MVP区别MVC model、view、controller分离，让彼此的职责分开，修改一层的时候，其他两层可以不动； View和model相关，但不会有直接的联系，而是由controller去决定model产生的资料，然后给view呈现，controller是两者之间的协调者； 增加可测试性。 MVVM model、view、viewModel分离，通过viewModel串接； viewModel相当于view的一个代理，负责直接对model沟通 view可是通过双向数据绑定和viewModel沟通，两者粘合度高，view只能从viewModel来获取model。 model中的数据一旦变化，会自动影响视图，而不需要控制器协调。 MVP view model presenter分离，p与vm类似； 所有控制v的都有p来做，v在原则上依赖p，但为做到关注点分离，在v和p中间会加入一个界面； Angular适用范围单页面，大型项目。 类库和框架的区别类库：一些函数的集合，帮助我们写web应用。起主导作用的是我们的代码。 如：jQuery 框架：一种特殊的、已经实现了的WEB应用，只需要对他填充具体的业务逻辑。框架起主导作用。 如：bootstrap angular既不是类库也不是框架，而是直接修改了我们看待HTML的方式。 但是使用的时候，当作类库使用。 AngularAngular是纯模块化开发的，所有提供的API都是模块化的。并由自己的依赖注入系统。符合AMD规范。 Angular是框架之母，React和Vue都受到了Angular的影响，数据变了会自动影响视图。 Angular1、2、4三代并存，由不同的团队负责研发升级，三代差别巨大，可以看作三个不同的框架。2开始全面采用TS语法，浏览器仅仅兼容到IE10。 NPM和Bowernpm 开始是管理后端依赖（Express、Mongoose）、项目依赖（webpack、gulp）、 后来npm改良，也支持前端依赖。 bower 专门为前端表现设计的包管理器，一切全部为前端考虑的。 npm 和bower 的最大区别，就是 npm 支持嵌套地依赖管理，而 bower只能支持扁平的依赖（嵌套的依赖，由程序员自己解决）。现在不建议使用bower了。官方已经停止维护，建议直接使用npm就可以了。 bower安装：npm i bower -g Angular模块1var app = angular.module("app", []); Angular控制器使用装饰者模式（仅用于angular1.x）创建控制器。 装饰者模式：对象打点调用函数，让对象本身被丰富。 12345678910/*实例化控制器的类*/&lt;div ng-controller='MyCtrl as myctrl'&gt; &#123;&#123;myctrl.a&#125;&#125;&lt;/div&gt;&lt;script&gt;//创建一个控制器的类，叫做MyCtrlapp.controller("MyCtrl",["$http",function($http)&#123;//$http是依赖注入进来的 this.a = '123'&#125;])；&lt;/script&gt; 控制器里使用this来定义类的属性，在ng-controller的时候会生成自己的实例。 一个类可以生成多个实例，也就是说可以被不同元素多次ng-controller，这样每个实例的a都是互相隔离，不干扰的。 双向数据绑定脏检查机制。 Angular服务服务是angular中的重要组成部分，为应用提供基于某个业务的功能。执行一个或多个相关任务的可重用代码。 Angular服务都是单例对象，这意味着永远只有一个实例被创建，他是惰性的，只有第一次使用的时候，服务才会被实例化。一旦被实例化，就不会被再次实例化。 内置服务$http 自定义服务service函数angular可以用service函数定义一个服务，这个服务实际上就是一个普通的函数，这个函数是个类，在使用时，会被系统自动的实例化一次，必须使用类名打点的方式调用其中的方法，如myService.circleSize()。 服务是惰性的，只有依赖这个服务的控制器被实例化时，服务才会被实例化。 服务是单例的，不管页面上有多少控制器使用这个服务，服务的实例只有一次。因此，可以完成两个控制器间的传值，类似于vuex。 定义服务和定义controller一样，都使用依赖注入的数组语法。服务也可以依赖服务。 控制器想使用服务，这个控制器就可以将这个服务设置为依赖即可。 服务只需要对自己的那个闭包数组负责，不需要对回调函数负责。 12345678910111213141516171819202122app.service('myService',[function()&#123; //方法 this.power = function (a) &#123; return a * a; &#125; this.pi = 3.14; this.circleSize = function(r) &#123; return this.pi * r * r; &#125; this.b = 2;&#125;]);//依赖注入服务，实例化服务app.controller('myCtrl',['myService', function(myService)&#123; //服务在控制器里的使用 this.n = function()&#123; return myService.power(100); &#125; //这个没有调用变量，可以不用函数return得值 this.a = myService.circleSize(5); //在控制器里也可以直接更改服务的值 myService.b = 22;&#125;]) factory函数返回一个对象的函数，就是工厂。Angular可以使用 12345678myapp.controller('myCtrl',["myService", function(myService) &#123; alert(myService.a);&#125;])myapp.factory('myService', [function()&#123; return &#123; a : 1 &#125;&#125;]) 一定要return一个对象，建议定义的时候，就直接把return写好。 factory中return的对象，会自动被服务名字的这个对象接收，也是打点调用。 也是单例对象。多个控制器使用同一个factory服务，返回的数值是相同的。 从底层来说，service调用的factory的方法。 service，可以用在函数内部用this定义变量，也可以用this来进行暴露，此时外部可以直接对属性进行修改，不安全。而factory有更好的封装性，严格的按照暴露的函数来操作内部属性。 两者非常相似，区别只在于： service定义的是构造函数，服务名一般首字母大写。里面可以用this定义属性方法，但记住，定义的是”类属性“，“类方法”，用的时候是类名打点； factory定义的是一个工厂，会返回一个对象，也就是一个API清单，更安全，factory中不能用this来定义属性方法，必须用return返回。 相同点： 都是惰性的，单例的。 provider函数是service、factory的底层函数。 唯一可以被配置的服务。 123456789101112131415161718192021myapp.controller('Ctrl',["myService",function(myService)&#123; alert(myService.a)&#125;])myapp.provider('myService',function()&#123; return &#123; setA : function(number) &#123;//这个函数没有对外暴露，他是供config配置的。 a = number &#125;, $get : function()&#123; var a = 123; return &#123;//这里面，是真正要被注入的服务 a : a &#125; &#125; &#125;&#125;)//配置一个服务。习惯写在最上面。但实际上配置顺序不会影响。//被配置的服务会自动注入，在原服务名后加上Provider就行，myService -&gt; myServiceProvidermyapp.config(function(myServiceProvider)&#123; myServiceProvider.setA(110);//此时setA被配置以后即可使用&#125;) 函数中，$get函数返回的obj，才是真正要被注入的服务。 其他函数是可以被配置的函数。使用config进行配置，配置顺序无所谓。 config通常用来配置$httpProvider，因为$http本身不支持post方法。 constant函数最简单的一种服务。 定义一个常量，然后使用。不用写函数。 常用于定义一些公共的常数，一般由它定义的服务，不会去改他的内容。 需要改变的话，一般用value服务。 12345678910111213myapp.controller("ctrl", ["myService", function(myService) &#123; alert(myService.pi); myService.fun(10);&#125;])myapp.constant('myService',&#123;//此处不需要写成函数，直接就是一个对象。 "pi" : 3.14, "obj" : &#123; a:1 &#125;, "fun" : function(r)&#123; return this.pi * r * r &#125;&#125;) 直接定义就是对象，这个对象是唯一的，打点调用。 value函数与constant基本一样。 但存放能被修改的公共的内容。 12345678910111213myapp.controller("ctrl", ["myService", function(myService) &#123; alert(myService.pi); myService.fun(10);&#125;])myapp.value('myService',&#123;//此处不需要写成函数，直接就是一个对象。 "pi" : 3.14, "obj" : &#123; a:1 &#125;, "fun" : function(r)&#123; return this.pi * r * r &#125;&#125;) 指令内置指令ng-model ng-repeat ng-show ng-if 自定义指令-directive123456789101112131415&lt;div my-directive&gt; 默认内容&lt;/div&gt;&lt;my-directive&gt;&lt;/my-directive&gt;&lt;div class="my-directive"&gt;&lt;/div&gt;&lt;!-- directive:myDirective --&gt;&lt;script&gt; var app = angular.module("app", []); //指令名称为驼峰命名，在实际使用时则是用短横线连接，如my-directive app.directive("myDirective",[function()&#123; return &#123; template : '&lt;h1&gt;hello&lt;/h1&gt;' &#125; &#125;])&lt;/script&gt; 让我们定义一些HTML可以识别的语法糖。 restrict属性上面案例，使用指令时有四种方式： 属性：&lt;div my-directive&gt; 标签：&lt;my-directive&gt;&lt;/my-directive&gt; class：&lt;div class=&quot;my-directive&quot;&gt;&lt;/div&gt; 注释：&lt; !-- directive:myDirective --&gt; (没人用) 如果固定想用某种方式使用指令，只需要定义时给他设置restrict属性： 1234567var app = angular.module("app", []);app.directive("myDirective",[function()&#123; return &#123; restrict: 'AECM'//A是属性，E是标签，C是class，M是注释。默认是AE template : '&lt;h1&gt;hello&lt;/h1&gt;' &#125;&#125;]) templateUrl属性可以讲html模板放在外面，angular用ajax技术读取这个模板，因此页面必须运行在服务器环境中，不能直接双击运行。 scope属性有三个值，true、false 默认情况下：控制器和指令的$scope是公用同一个对象。 想改变这样的情况，需要修改指令创建对象的scope对象。 false：默认情况，两者公用一个scope对象； true：控制器的$scope指令能看见，但指令私有自己的$scope，类似于函数包裹函数。 对象：表示自定义指令上，设置的属性的数据绑定模式 @ 表明完成单向数据绑定 = 表明完成双向数据绑定 &amp; 表明绑定的HTML属性是一个函数。 link属性是个函数，有三个参数，第一个是$scope，第二个是元素，第三个是属性 作用：连接自定义指令里面的东西，和外部实现。 $scope在link函数的$scope里定义的变量、方法，都可以在外置模板中访问到。 相当于是外置模板的一个作用域。 attr包含自定义指令上，所有设置的属性值。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2019%2F07%2F22%2FAJAX%2F</url>
    <content type="text"><![CDATA[AJAX是基于XHR(XMLHTTPRequest)的一种，不用刷新整个浏览器就可以与服务器进行异步通信的技术。 传统方式： 浏览器直接访问Tomcat的Servlet来获取数据。Servlet通过转发把数据发送给浏览器。 AJAX方式： 浏览器将请求存放在XHR对象中，XHR将请求封装，然后发送给服务器。服务器并不是以转发的方式响应，而是以流的方式把数据返回给浏览器 优缺点优点 不用刷新整个浏览器 异步交互，响应更快 按需取用数据，减少冗余请求或响应对服务器造成的压力 基于标准的技术，兼容性好 缺点 不支持浏览器的回退功能 安全问题不太好，把和服务器的交互细节暴露出来了 不利于搜索引擎 破坏了浏览器的异常机制 不容易调试 原理创建一个XMLHTTPRequest对象 -&gt; 创建一个新的HTTP请求，确定请求方法、URL、验证信息 -&gt; 创建HTTP请求状态改变时的回调函数 -&gt; 发送HTTP请求 -&gt; 接收响应数据 -&gt; 使用JS或DOM进行浏览器局部刷新 XMLHTTPRequest对象Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。 方法open()创建HTTP请求 第一个参数是指定提交方式(post、get) 第二个参数是指定要提交的地址是哪 第三个参数是指定是异步还是同步(true表示异步，false表示同步) 第四和第五参数在http认证的时候会用到。是可选的 send()发送请求 get不需要填写 post填写需要提交的参数 setRequsetHeader()设置消息头 属性readyState：请求状态 0：未初始化 1：open方法调用后 2：服务器已经应答客户端请求 3：交互中，HTTP请求已经接收，还没有返回响应 4：数据接受完成。 onreadystatechange：请求状态改变时的事件触发器 responseText：服务器返回的文本内容 responseXML：服务器返回的XML内容 status：服务器返回的状态码 statusText：服务器返回的状态码的文本信息 八种Callback onSuccess onFailure onUninitialized onLoading onLoaded onInteractive onComplete onException HTTP状态码 2xx (成功)表示成功处理了请求的状态代码 3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理 5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错 200 OK 客户端请求成功 301 资源(网页等)被永久转移到其他URL 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 手写一个AJAX12345678910111213141516//ajax编写步骤// 1、创建XMLHttpRequest对象 var xhr = new XMLHttpRequest();// 2、设置请求参数 xhr.open(请求方式,请求地址,异步或同步);// 3、设置回调函数 xhr.onreadystatechange = function()&#123; if(xhr.reasyState===4)&#123; if(xhr.status === 200) &#123; //5、接受响应 console.log(xhr.responseText); &#125; &#125; &#125;// 4、发送请求 xhr.send(); IE中通过new ActiveXObject()得到，Firefox中通过newXMLHttpRequest()得到 jQuery中的ajax请求类型（8种） GET 请求指定的页面信息，并返回实体主体。 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 PUT 从客户端向服务器传送的数据取代指定的文档的内容 DELETE 请求服务器删除指定的页面 OPTIONS 允许客户端查看服务器的性能 TRACE 请求服务器在响应中的实体主体部分返回所得到的内容 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 GET和POST区别 GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中 GET 用于获取信息，是无副作用的，是幂等的，且可缓存 ；POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存 GET请求能够被缓存，GET请求会保存在浏览器的浏览记录中，以GET请求的URL能够保存为浏览器书签，post请求不具有这些功能 安全性从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。 要想安全传输，就只有加密，也就是 HTTPS。 但是相对来说，post比get安全一点点。 大小get的长度限制，是由于浏览器对url的限制，而不是方法本身的限制。 Ajax 解决浏览器缓存问题1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。 2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。 3、在URL后面加上一个随机数： “fresh=” + Math.random();。 4、在URL后面加上时间戳：”nowtime=” + new Date().getTime();。 5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。 跨域理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域。 所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，【JSONP】 在后端上配置可跨域【CORS方式】 前端ajax请求的是本地接口，本地接口接收到请求后向实际的接口请求数据，然后再将信息返回给前端【代理方式】 两个窗口间的通信，可以使用otherWindow.postMessage(message, targetOrigin, [transfer]);将数据传送给指定的url，目标窗口通过执行addEventListener侦听发送过来的消息，【window.postMessage()】]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS引擎机制]]></title>
    <url>%2F2019%2F07%2F22%2FJS%E5%BC%95%E6%93%8E%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[语法分析 浏览器按顺序加载由标签分割的js代码块 加载完毕 进入代码块 语法分析 有报错，停止当前语法分析，进入下一个代码块进行语法分析 无报错，进入预编译 预编译进入全局环境 创建全局执行上下文 创建变量对象 创建变量对象发生在预编译阶段，但尚未进入执行阶段，该变量对象都是不能访问的，因为此时的变量对象中的变量属性尚未赋值，值仍为undefined，只有进入执行阶段，变量对象中的变量属性进行赋值后，变量对象（Variable Object）转为活动对象（Active Object）后，才能进行访问，这个过程就是VO –> AO过程。 检查当前上下文的函数声明 函数声明提前 如果当前上下文的变量对象没有该函数名属性，则在该变量对象以函数名建立一个属性，属性值则为指向该函数所在堆内存地址的引用 如果存在，则会被新的引用覆盖 检查当前上下文的变量声明 变量声明提前 如果当前上下文的变量对象没有该变量名属性，则在该变量对象以变量名建立一个属性，属性值为undefined 如果存在，则忽略该变量声明 window对象就是全局执行上下文的变量对象，所有的变量和函数都是window对象的属性方法。 创建作用域链 作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 作用域链的活动对象或变量对象可以直接理解为作用域。 作用域链的第一项永远是当前作用域（当前上下文的变量对象或活动对象）； 最后一项永远是全局作用域（全局执行上下文的活动对象）； 作用域链保证了变量和函数的有序访问，查找方式是沿着作用域链从左至右查找变量或函数，找到则会停止查找，找不到则一直查找到全局作用域，再找不到则会抛出引用错误。 确定this指向 全局执行上下文中变量对象的this属性指向为window 推入stack栈中 调用函数，进入函数运行环境 创建函数执行上下文 创建变量对象 创建anguments对象 检查当前上下文中的参数 建立该对象的属性与属性值 仅在函数环境(非箭头函数)中进行 检查当前上下文的函数声明 函数声明提前 如果当前上下文的变量对象没有该函数名属性，则在该变量对象以函数名建立一个属性，属性值则为指向该函数所在堆内存地址的引用 如果存在，则会被新的引用覆盖 检查当前上下文的变量声明 变量声明提前 如果当前上下文的变量对象没有该变量名属性，则在该变量对象以变量名建立一个属性，属性值为undefined 如果存在，则忽略该变量声明 建立作用域链 确定this指向 推入stack栈中 执行JS是单线程的，为避免代码解析阻塞通过事件循环（Event Loop）使用了异步执行 会有四个线程参与该过程，但是永远只有JS引擎线程在执行JS脚本程序，其他的三个线程只协助，负责将满足触发条件的处理函数推进事件队列，不参与代码解析与执行。 JS引擎线程： 也称为JS内核，负责解析执行Javascript脚本程序的主线程（例如V8引擎） 事件触发线程： 归属于浏览器内核进程，不受JS引擎线程控制。主要用于控制事件（例如鼠标，键盘等事件），当该事件被触发时候，事件触发线程就会把该事件的处理函数推进事件队列，等待JS引擎线程执行 定时器触发线程：主要控制计时器setInterval和延时器setTimeout，用于定时器的计时，计时完毕，满足定时器的触发条件，则将定时器的处理函数推进事件队列中，等待JS引擎线程执行。注：W3C在HTML标准中规定setTimeout低于4ms的时间间隔算为4ms。 HTTP异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。注：浏览器对通一域名请求的并发连接数是有限制的，Chrome和Firefox限制数为6个，ie8则为10个。​​ 执行顺序：宏任务(同步任务) --> 微任务 --> 宏任务(异步任务)​进入ES6或Node环境中，JS的任务分为两种，分别是宏任务（macro-task）和微任务（micro-task），在最新的ECMAScript中，微任务称为jobs，宏任务称为task，他们的执行顺序如上。​​ 宏任务（macro-task） 同步任务同步任务指的是在JS引擎主线程上按顺序执行的任务，只有前一个任务执行完毕后，才能执行后一个任务，形成一个执行栈（函数调用栈）。 异步任务异步任务指的是不直接进入JS引擎主线程，而是满足触发条件时，相关的线程将该异步任务推进任务队列(task queue)，等待JS引擎主线程上的任务执行完毕，空闲时读取执行的任务，例如异步Ajax，DOM事件，setTimeout等。 微任务微任务是在es6和node环境中出现的一个任务类型，如果不考虑es6和node环境的话，我们只需要理解宏任务事件循环的执行过程就已经足够了，但是到了es6和node环境，我们就需要理解微任务的执行顺序了。 微任务（micro-task）的API主要有:Promise， process.nextTick 事件循环 首先执行宏任务的同步任务，在主线程上形成一个执行栈，可理解为函数调用栈； 当执行栈中的函数调用到一些异步执行的API（例如异步Ajax，DOM事件，setTimeout等API），则会开启对应的线程（Http异步请求线程，事件触发线程和定时器触发线程）进行监控和控制 当异步任务的事件满足触发条件时，对应的线程则会把该事件的处理函数推进任务队列(task queue)中，等待主线程读取执行 当JS引擎主线程上的任务执行完毕，则会读取任务队列中的事件，将任务队列中的事件任务推进主线程中，按任务队列顺序执行 当JS引擎主线程上的任务执行完毕后，则会再次读取任务队列中的事件任务，如此循环，这就是事件循环（Event Loop）的过程 主线程执行栈 异步任务等待触发 任务队列 任务队列(task queue)就是以队列的数据结构对事件任务进行管理，特点是先进先出，后进后出。 一些知识点高频触发事件可能会引起页面卡顿，我们可以利用setTimeout实现计时器的原理，对高频触发的事件进行优化，实现点在于将多个触发事件合并成一个，这就是防抖和节流。 使用setTimeout实现计时功能是比setInterval性能更好的（当然如果不需要兼容低版本的IE浏览器，使用requestAnimationFrame是更好的选择。） 原因： setTimeout实现setInterval只能通过递归调用 setTimeout是在到了指定时间的时候就把事件推到任务队列中，只有当在任务队列中的setTimeout事件被主线程执行后，才会继续再次在到了指定时间的时候把事件推到任务队列，那么setTimeout的事件执行肯定比指定的时间要久，具体相差多少跟代码执行时间有关 setInterval则是每次都精确的隔一段时间就向任务队列推入一个事件，无论上一个setInterval事件是否已经执行，所以有可能存在setInterval的事件任务累积，导致setInterval的代码重复连续执行多次，影响页面性能。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue常见问题集锦]]></title>
    <url>%2F2019%2F07%2F21%2Fvue%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[MVVM模式 简述MVVM模式model数据模型-viewUI视图-view model负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作 Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。 这种模式实现了Model和View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作dom。 Vue常用指令v-if、v-show、v-bind、v-on、v-model、v-for、v-html等 v-if和v-show的区别v-show控制的是元素的display属性，而v-if控制的是DOM节点的存在与否。 v-show的切换开销更小，v-if的初始开销更小。 简述Vue的响应式原理（双向数据绑定）数据劫持+订阅者模式。 数据劫持：​ 当我们访问或设置对象的属性的时候，都会触发相对应的函数，然后在这个函数里返回或设置属性的值。既然如此，我们当然可以在触发函数的时候动一些手脚做点我们自己想做的事情，这也就是“劫持”操作。在Vue中其实就是通过Object.defineProperty来劫持对象属性的setter和getter操作，并“种下”一个监听器，当数据发生变化的时候发出通知。 发布-订阅者模式：​ 其定义对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。Vue通过observe(观察)每个对象的属性，添加到订阅器dep中，当数据发生变化的时候发出一个notice（预告）。 当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 Vue中如何在组件内部实现一个双向数据绑定？可以直接用v-model指令。 不用v-model的话，可以使用： 父组件通过props传值给子组件，子组件通过 $emit 来通知父组件修改相应的props值。 Vue中如何监控某个属性值的变化 用watch监听。 用computed，返回一个计算后的属性，当属性值改变时，计算属性会重新计算返回。 Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？因为在实例挂载时，没有这个属性，因此增加的属性会增加上去，但是不会刷新视图。 解决办法：使用$set() 方法，相当于手动的把新增的属性，处理成一个响应式的属性。 delete和Vue.delete删除数组的区别 delete只是被删除的元素变成了 empty/undefined ，其他的元素的键值还是不变。 Vue.delete 直接删除了数组 改变了数组的键值。 vue混合模式插槽slot在组件外部灵活控制组件内部的内容一种形式或者是入口，就是将组件内所需要的内容以插槽（slot）的形式插入到公共组件中，以达到灵活控制。当组件渲染的时候，这个 &lt;slot&gt; 元素将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML VUE中template编译的理解先转化成AST(抽象语法树)，然后通过render函数进行渲染，并返回VNode。 1、通过compile编译器将其编译成AST； 2、AST经过generate得到render函数，返回值是个VNode。 简述VUEX数据单向流动 一个应用可以看作是由上面三部分组成: View, Actions,State,数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动. 但是项目较大的, 组件嵌套过多的时候, 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的. Vuex可以被看作项目中所有组件的数据中心,我们将所有组件中共享的State抽离出来,任何组件都可以访问和操作我们的数据中心 Vuex的组成：一个实例化的Vuex.Store由state, mutations和actions三个属性组成: state中保存着共有数据 改变state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的 如果要写异步的方法,需要些在actions中, 并通过commit到mutations中进行state中数据的更改. 在main.js引入store，注入。 简述vue-router使用hash或者pushstate，监听hashchange事件，来截取location.href.hash的值。 怎么定义vue-router的动态路由？怎么获取传过来的动态参数？**在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id 例如 : this.$route.params.id; 怎么写一个VUE组件Vue.component或者components。 如何优化SPA应用的首屏加载速度慢的问题 将公用的JS库通过script标签外部引入，减小 app.bundel 的大小，让浏览器并行下载资源文件，提高下载速度； 在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件； 加一个首屏loading图，提升用户体验； vue中 key 值的作用key 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。 有相同父元素的子元素必须有独特的key。重复的key会造成渲染错误。 VUE虚拟DOM用传统JS来渲染DOM树时，需要将DOM树从头到尾解析挂载渲染一遍，而虚拟DOM可以在进行多次DOM操作时，不会立即执行DOM更新，而是将多次的操作存储在虚拟DOM上，最终一次性操作DOM树。 可以减少多次操作下DOM的多次更新，优化性能。 axios理解及使用使用 npm i axios -s安装 import导入 Vue.prototype.$http = axios将其简单封装 1、axios的特点有哪些？ Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API 它可以拦截请求和响应 它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据 安全性更高，客户端支持防御 XSRF 2、axios有哪些常用方法？ axios.get(url[, config]) //get请求用于列表和信息查询 axios.delete(url[, config]) //删除 axios.post(url[, data[, config]]) //post请求用于信息的添加 axios.put(url[, data[, config]]) //更新操作 3、说下你了解的axios相关配置属性？ url是用于请求的服务器URL method是创建请求时使用的方法,默认是get baseURL将自动加在url前面，除非url是一个绝对URL。它可以通过设置一个baseURL便于为axios实例的方法传递相对URL transformRequest允许在向服务器发送前，修改请求数据，只能用在’PUT’,’POST’和’PATCH’这几个请求方法 headers是即将被发送的自定义请求头 params是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象 auth表示应该使用HTTP基础验证，并提供凭据这将设置一个Authorization头，覆写掉现有的任意使用headers设置的自定义Authorization头 proxy定义代理服务器的主机名称和端口 axios拦截器axios.interceptors.request.use axios.interceptors.response.use 导航守卫全局守卫 beforeEach beforeResolve afterEach 路由守卫 beforeEnter 组件内守卫 beforeRouterEnter beforeRouterUpdte beforeRouterLeave]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端 - 面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue从入门到放弃のvuex]]></title>
    <url>%2F2019%2F07%2F12%2Fvue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E3%81%AEvuex%2F</url>
    <content type="text"><![CDATA[每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。 Vuex是一个专为Vue服务，用于管理页面数据状态、提供统一数据操作的生态系统。它集中于MVC模式中的Model层，规定所有的数据操作必须通过 action - mutation - state change 的流程来进行，再结合Vue的数据视图双向绑定特性来实现页面的展示更新。统一的页面状态管理以及操作处理，可以让复杂的组件交互变得简单清晰，同时可在调试模式下进行时光机般的倒退前进操作，查看数据改变过程，使code debug更加方便。 如图示，Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能： Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch：操作行为触发方法，是唯一能执行action的方法。 actions：操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations：状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。 使用12345678910111213141516//store.jsimport Vue from 'vue';import vuex from 'vuex'Vue.use(vuex);var store = new vuex.Store(&#123;//store对象 state:&#123; show:false &#125;&#125;)//index.jsconst app = new Vue(&#123; el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store&#125; 属性state:提供一个响应式数据； Getter:借助Vue的计算属性computed来实现缓存； Mutation:更改state方法； Action:触发mutation 方法； Module:Vue.set 动态添加state 到响应式数据中； 在 Vue 组件中获得 Vuex 状态在组件的计算属性中返回某个状态123456789// 创建一个 Counter 组件const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return store.state.count &#125; &#125;&#125; 每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。 然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。 将状态从根组件“注入”到每一个子组件中Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）： 1234567891011const app = new Vue(&#123; el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: &#123; Counter &#125;, template: ` &lt;div class="app"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现：S 12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; 辅助函数在使用过程中，业务功能逐渐增加，会出现很多个状态。当一个组件需要多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。 mapState mapMutation mapGetter mapAction]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vuex</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷题涉及到的知识点]]></title>
    <url>%2F2019%2F07%2F08%2F%E5%88%B7%E9%A2%98%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[undefined和null与任何有意义的值比较返回的都是false，但是null与undefined之间互相比较返回的是true。 Null： null是js中的关键字，表示空值，null可以看作是object的一个特殊的值，如果一个object值为空，表示这个对象不是有效对象。 Undefined: undefined不是js中的关键字，其是一个全局变量，是Global的一个属性，以下情况会返回undefined: 1）使用了一个未定义的变量；var i; 2）使用了已定义但未声明的变量； 3）使用了一个对象属性，但该属性不存在或者未赋值； 4)调用函数时，该提供的参数没有提供： NAN(no a number ) 1、操作的两个数，类型不一致 2、有一个值为NaN，计算後为NaN 只能输入零／非零开头的数字^ 以。。。开头，$以。。。结尾。*任意多次|或的意思（）组[]集合 Yahoo! User Interface 库 (YUI) 包含一个 bucketload 。 和 YUI 一样， ExtJS 包含大量开箱即用的组件，其中有很多功能强大的网格控件，支持内联编辑、分页、筛选、分组、汇总、缓冲和数据绑定。 MooTools 和 Prototype 、 jQuery 不包含开箱即用的 UI 控件和小部件. noscript 元素用来定义在脚本未被执行时的替代内容（文本）。 两个字符串相加，不会隐式转换 ‘2’+‘1’ = ‘21’ for in会忽略到不可枚举的元素，所以不一定是按顺序的 加号优先级高于 三目运算。低于括号。 所以括号中无论真假 加上前边的字符串都为 TRUE 三目运算为TRUE是 输出 define 1console.log(&apos;Value is &apos; + (val != &apos;0&apos;) ? &apos;define&apos; : &apos;undefine&apos;); JavaScript RegExp 对象有 3 个方法：test()、exec() 和 compile()。(1) test() 方法用来检测一个字符串是否匹配某个正则表达式，如果匹配成功，返回 true ，否则返回 false；(2) exec() 方法用来检索字符串中与正则表达式匹配的值。exec() 方法返回一个数组，其中存放匹配的结果。如果未找到匹配的值，则返回 null；（3）compile() 方法可以在脚本执行过程中编译正则表达式，也可以改变已有表达式。 非独立：JavaScript语言依赖执行环境，对于客户端来说是浏览器，对于服务端来说是node。 效率低：执行前不需要编译，执行时才编译，因此效率低。 12345678alert($(window).height()); //浏览器当前窗口可视区域高度 alert($(document).height()); //浏览器当前窗口文档的高度 alert($(document.body).height());//浏览器当前窗口文档body的高度 alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin alert($(window).width()); //浏览器当前窗口可视区域宽度 alert($(document).width());//浏览器当前窗口文档对象宽度 alert($(document.body).width());//浏览器当前窗口文档body的高度 alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin 数据类型 转换为true 转换为false boolean true false String 任何非空字符串 空字符串 Number 任何非零数字值 0和NaN Object 任何对象 null Undefined n/a undefined void是一元运算符，它出现在操作数之前，操作数可以是任意类型，操作数会照常计算，但忽略计算结果并返回undefined。由于void会忽略操作数的值，因此在操作数具有副作用的时候使用void来让程序更具语义 +是一元运算符，相当于我们说的正负，无运算效果，但是可以将字符串等转为number类型 布尔类型与其它任何类型进行比较，布尔类型将会转换为number类型。 Number([])返回0，Number({})返回NaN。 onBlur:当失去输入焦点后产生该事件 onFocus:当输入获得焦点后，产生该文件 onchange:当文字值改变时，产生该事件 onselect:当文字加亮后，产生该事件 onClick：当组件被点击时产生的事件 白屏时间（first Paint Time）——用户从打开页面开始到页面开始有东西呈现为止 首屏时间——用户浏览器首屏内所有内容都呈现出来所花费的时间 用户可操作时间(dom Interactive)——用户可以进行正常的点击、输入等操作，默认可以统计domready时间，因为通常会在这时候绑定事件操作 1234567//ajax的事件是： ajaxComplete(callback) ajaxError(callback) ajaxSend(callback) ajaxStart(callback) ajaxStop(callback) ajaxSuccess(callback) 1.Javascript中，由于其变量内容不同，变量被分为基本数据类型变量和引用数据类型变量。基本类型变量用八字节内存，存储基本数据类型(数值、布尔值、null和未定义)的值，引用类型变量则只保存对对象、数组和函数等引用类型的值的引用(即内存地址)。 2. JS中的数字是不分类型的，也就是没有byte/int/float/double等的差异。 angularjs的服务是一个单例对象或函数，对外提供特定的功能。 12345function a(a)&#123; a^=(1&lt;&lt;4)-1; return a;&#125; &lt;&lt;为左移运算符，0001左移四位后是10000，是16,16-1=15，故结果为15 汉诺塔：2^n-1 Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径，所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。 相反，./ 会返回你执行 node 命令的路径，例如你的工作路径。 有一个特殊情况是在 require() 中使用 ./ 时，这时的路径就会是含有 require() 的脚本文件的相对路径。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他问题集锦]]></title>
    <url>%2F2019%2F07%2F07%2F%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[谈谈你对SEO的理解SEO：搜索引擎优化，其目的是为了使网站能够更好的被搜索引擎抓取，提高在搜索引擎内的自然排名，从而带来更多的免费流量，获取收益 SEO主要有两种方法，站内优化和站外优化 TDK优化： TDK为title,description,keywords三个的统称 title：标题唯一，主题明确凝练，越重要的越在前面 description：准确的摘要，PC端70字，移动端50字 结构优化： 使用HTML5语义化标签 唯一的h1标题 img设置alt属性 不需要跟踪的设置nofollow URL优化： SEO工具： 百度指数 站长平台 前端怎么管理路由基于 hash（ocation.hash+hashchange事件）兼容性更好 展示层面也就是切换 # 后面的内容，呈现给用户不同的页面。现在越来越多的单页面应用，基本都是基于 hash 实现 url 中 hash 值的变化并不会重新加载页面 hash 值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制 hash 的切换 我们可以通过 hashchange 事件，监听到 hash 值的变化，从而响应不同路径的逻辑处理 基于 history 新 API（ history.pushState()+popState 事件） 1window.history.pushState(null, null, &quot;http://www.google.com&quot;); 这两个 API 的相同之处是都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于，pushState 会增加一条新的历史记录，而 replaceState 则会替换当前的历史记录 页面重构怎么操作根据原有页面内容和结构的基础上，通过 div+css 写出符合 web 标准的页面结构。 具体实现要达到以下三点： 功能不全页面的重构：页面功能符合用户体验、用户交互结构完整，可通过标准验证， 代码重构：代码质量、SEO 优化、页面性能、更好的语义化、浏览器兼容、CSS 优化 充分考虑到页面在站点中的“作用和重要性”，并对其进行有针对性的优化 什么是HTTP持久化和管线化HTTP 最初的版本中，每进行一次 HTTP 通信，就要断开一次 TCP 连接（无连接） 为解决上述问题，HTTP/1.1 增加了持久连接（HTTP Persistent Connections ）的方法，其特点是，只要一方未明确提出断开连接，则另一方保持 TCP 连接状态 管线化是指将多个 HTTP 请求整批发送，在发送过程中不用等待对方响应 管线化是在持久连接的基础上实现的，管线化的实现，能够同时并行发送多个请求，而不需要一个接一个的等待响应 http和https协议有什么区别http: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少 https: 是以安全为目标的HTTP通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL ，因此加密的详细内容就需要 SSL http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443 http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全 网页从输入网址到渲染完成经历了哪些过程？ 输入网址； 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址； 与web服务器建立TCP连接； 浏览器向web服务器发送http请求； web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）； 浏览器下载web服务器返回的数据及解析html源文件； 生成DOM树，解析css和js，渲染页面，直至显示完成；]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS常见问题集锦]]></title>
    <url>%2F2019%2F07%2F06%2FJS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[JavaScript有哪些数据类型 原始类型 number string boolean null undefined symbol：符号类型是唯一的并且是不可修改的，ES6定义 引用类型 object object function array date regexp 怎么判断数据类型 typeof：返回一个字符串，表示未经计算的操作数的类型 instanceof：用来判断A 是否是 B的实例，表达式为 A instanceof B，返回一个Boolean类型的值 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型 constructor：当一个函数被定义时，JS引擎会为其添加prototype原型，然后再在 prototype上添加一个 constructor 属性，并让其指向该函数的引用。 toString： Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。 这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型 原始类型可以直接用typeof判断，引用类型可以用toString判断，instanceof用于判断实例，constructor判断函数原型 undefined和null的区别 Null表示一个空值，转为数值时为0，对null执行typeof运算，返回字符串“object” undefined表示未定义，转为数值时为NaN，用typeof运算符得到undefined类型 数组最大长度array的最大长度为Math.pow(2,32)-1var arr = new Array(Math.pow(2,32));//报错Invalid array length 数组对象的常用方法 修改器方法 pop(): 删除数组的最后一个元素，并返回这个元素 push()：在数组的末尾增加一个或多个元素，并返回数组的新长度 reverse(): 颠倒数组中元素的排列顺序 shift(): 删除数组的第一个元素，并返回这个元素 unshift(): 在数组的开头增加一个或多个元素，并返回数组的新长度 sort(): 对数组元素进行排序，并返回当前数组 splice(): 在任意的位置给数组添加或删除任意个元素 entries()：返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。（也就是将数组变成对象，键名是下标，键值是value） copyWithin(target, start, end)：从数组的指定位置拷贝元素到数组的另一个指定位置中。 访问方法 concat(): 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组 join(): 连接所有数组元素组成一个字符串，比起toString可以用其他的东西来代替逗号 toString()：连接所有数组元素组成一个字符串 slice(startnum,endnum): 抽取当前数组中的一段元素组合成一个新数组 indexOf(): 返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1 lastIndexOf(): 返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1 includes()：判断一个数组是否包含一个指定的值，如果是返回 true，否则false reduce()：接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 reduceRight()：同上，但是反向。 迭代方法 forEach(function(currentValue, index, arr), thisValue): 为数组中的每个元素执行一次回调函数,最终返回 undefined every(function(currentValue,index,arr), thisValue): 如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false some(): 如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false filter(): 将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回 map(): 返回一个由回调函数的返回值组成的新数组 from(object, mapFunction, thisValue)：通过拥有 length 属性的对象或可迭代的对象来返回一个数组。如果对象是数组返回 true，否则返回 false。 find()：返回通过测试（函数内判断）的数组的第一个元素的值，当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined findIndex()：当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1 字符串对象的常用方法 数组对象中也有的方法 concat()：连接两个字符串，并返回新的字符串 includes()：判断字符串中是否包含指定的子字符串 indexOf()：返回指定的字符串值在字符串中首次出现的位置。 lastIndexOf()：返回指定字符串在字符串中最后一次出现的位置 slice()：提取字符串的片断，并在新的字符串中返回被提取的部分。 toString()：返回一个字符串。 字符串特有的方法： charAt()：可返回指定位置的字符。 charCodeAt()：返回指定位置字符的Unicode码 fromCharCode()：将Unicode编码转化成字符 match()：查找一个或多个正则表达式的匹配，返回一个数组 repeat()：复制字符串指定次数，并将它们连接在一起返回。 replace()：在字符串中寻找符合正则表达式匹配的子串，并替换。 search()：查找与正则表达式匹配的值。 split()：将字符串按照规则分割为数组。 startsWith()：查看字符串是否以指定的子字符串开头。 substr()：从起始索引号提取字符串中指定数目的字符 substring()：提取字符串中两个指定的索引号之间的字符。 toLowerCase()：把字符串转换为小写。 toUpperCase()：把字符串转换为大写。 trim()：去除字符串两边空格 Math对象的常用方法 abs()：返回绝对值 min()：返回给定数值中最小的 max()：返回给定数值中最大的 random()：返回0-1间的左闭右开随机数，Math.random() *（上限-下限）+下限 ceil()：将给定数值进行上取整 floor()：将给定数值进行下取整 round()：将给定数值进行四舍五入为最近的数 Js 有哪几种创建对象的方式 字面量 1var obj = &#123;&#125; Object构造函数 1var obj = new Object() 工厂模式 123456789function Person(name,age)&#123; var o = new Object(); o.name = name; o.age = age; o.say = function()&#123; console.log(name); &#125; return o;&#125; 缺点： 每次通过Person创建对象的时候，所有的say方法都是一样的，但是却存储了多次，浪费资源 构造函数模式 12345678function Person(name, age) &#123; this.name = name this.age = age this.say = function() &#123; console.log(name) &#125;&#125;var person = new Person('hello', 18) 构造函数模式隐式的在最后返回return this 所以在缺少new的情况下，会将属性和方法添加给全局对象，浏览器端就会添加给window对象,可以根据return this 的特性调用call或者apply指定this 原型模式 1234567function Person() &#123;&#125;Person.prototype.name = 'hanmeimei';Person.prototype.say = function() &#123; alert(this.name);&#125;Person.prototype.friends = ['lilei'];var person = new Person(); 实现了方法与属性的共享，可以动态添加对象的属性和方法。但是没有办法创建实例自己的属性和方法，也没有办法传递参数 构造函数和原型组合 12345678function Person(name, age) &#123; this.name = name this.age = age&#125;Person.prototype.say = function() &#123; console.log(this.name)&#125;var person = new Person('hello') 怎么实现对对象的拷贝(浅拷贝与深拷贝)深拷贝和浅拷贝是由于引用类型在常规的复制情况下，只复制了地址，并没有复制出值。 浅拷贝的实现： 123456789101112function copy(obj) &#123; if(!obj || typeof obj !== 'object') &#123; throw new Error('error'); &#125; var targetObj = obj.constructor === Array? [] : &#123;&#125;; for(var keys in obj) &#123; if (obj.hasOwnProperty(keys)) &#123; targetObj[keys] = obj[keys]; &#125; &#125; return targetObj;&#125; 深拷贝的实现： 12345678910111213141516function deepCopy(obj) &#123; if(!obj || typeof obj !== 'object') &#123; throw new Error('error'); &#125; var targetObj = obj.constructor === Array? [] : &#123;&#125;; for(var keys in obj) &#123; if (obj.hasOwnProperty(keys)) &#123; //忽略掉那些从原型链上继承到的属性 if (typeof obj[keys] === 'object') &#123; targetObj[keys] = deepCopy(obj[keys]); &#125; else &#123; targetObj[keys] = obj[keys]; &#125; &#125; &#125; return targetObj;&#125; 结果： 123456789101112131415161718192021var a = &#123; name: 'name', age: 'age', number: &#123; 1: '1', 2: '2', 3: '3', 4: '4', 5: [] &#125;&#125;var b = copy(a);var c = deepCopy(a);console.log(b);console.log(c);b.number[1] = '12';c.number[2] = '22';//浅拷贝时，只是地址的引用，并没有进行值的复制，因此改变b还是会影响a的值//深拷贝时，是值的复制，因此改变c不会影响a,b，ab的改变也不会影响cconsole.log(a,b,c); 什么是闭包，为什么要使用它闭包是指能读取其他函数内部变量的函数。 12345678function parent() &#123; var name = 'parent'; function child() &#123; console.log(name); &#125; return child();&#125;parent(); 可以读取函数内部的变量 让变量的值一直保存，被引用就不会被释放，会导致内存泄露 保存的变量都在内存里，内存消耗大，因此不能滥用闭包 介绍JS原型及原型链，它们有什么特点js是基于原型的语言，每个对象都有一个原型对象，对象以其原型为模板，继承原型的属性和方法，这些属性和方法实际上定义在构造器函数的prototype上，而非实例本身，实例和构造期间建立了一个链接关系。 每个实例的_proto_都指向其构造函数的prototype对象 每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象 原型对象默认拥有一个constructor属性，指向指向它的那个构造函数 所有对象都有_proto_，但只有函数才有prototype，原型链根据_proto_指向寻找 获取对象原型可以根据Object.getPrototypeOf(obj)来查找，_proto_已被废弃，尽量不用 而原型对象本身也是对象，它也拥有原型，这样就形成了一个原型链。 原型链最高级是Object的原型对象，它的原型是Null，null不存在原型。 JS如何实现继承原型链继承：1234567function Parent() &#123;&#125;Parent.prototype.name = 'parent';Parent.prototype.method = function () &#123; console.log(this.name);&#125;var child = new Parent();child.method();//parent 构造继承：1234567891011function Parent1() &#123; this.name = 'parent'; this.method = function () &#123; console.log(this.name); &#125;&#125;function Child1() &#123; Parent1.call(this);&#125;var child1 = new Child1();child1.method();//parent 组合继承(伪经典继承)：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性。 1234567891011function Parent2() &#123; this.name = 'parent';&#125;function Child2() &#123; Parent2.call(this); this.method = function () &#123; console.log(this.name); &#125;&#125;Child2.prototype = new Parent2();Child2.prototype.constructor = Child2; extends继承：ES6新增继承方式，Class 可以通过extends关键字实现继承 123456789class Animal &#123; &#125;class Cat extends Animal &#123; constructor() &#123; super(); &#125;&#125; 使用 extends 实现继承，必须添加 super 关键字定义子类的 constructor，这里的super() 就相当于 Animal.prototype.constructor.call(this) NEW操作符干了什么 创建一个新对象，这个新对象会被执行[[Prototype]]连接。 并将this绑定在新对象上 继承函数的原型，并且将属性和方法加入到新对象上 如果函数没有其他返回对象，则会自动返回这个新对象 同步和异步的区别，怎么异步加载JS 同步会阻塞，加载js的时候就停下其他事情 异步不会阻塞，边加载js边会处理后续页面 异步加载JS，使用defer、async或者动态添加script标签 defer是等html加载完以后再执行 async是加载完就直接执行 动态添加 script 标签 跨越问题的产生及解决 产生 不符合浏览器的同源策略 端口、域名、协议不一致时，就会出现跨域问题 属于一种安全限制 解决 jsonp：动态创建script，再请求一个带参网址实现跨域通信.缺点就是只能实现 get 一种请求 document.domian+iframe：两个页面都通过js强制设置document.domain为基础主域，就实现了同域.但是仅限主域相同，子域不同的跨域应用场景 websocket跨域： nginx反向代理接口跨域：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题 跨域资源共享CORS：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置 this的理解 this是当前执行上下文对象，即被调用函数所处的环境。 有多种绑定方式，主要看函数的调用位置。 一般情况下直接调用的函数，绑定在全局。 箭头函数的this则是根据外层词法作用域绑定，不能用call这些来直接改变，但是可以间接改变。 点符号调用的，一般会绑定在点符号之前的对象上。 用call、apply、bind直接强制改变this指向，是显式绑定。（硬绑定） 但是也有特殊情况，比如隐式调用，将一个对象中的函数赋值给另一个变量，用变量调用的时候，就相当于是直接在全局调用当前函数，会丢失绑定对象，this就指向全局。可以用bind解决绑定丢失。 我们用new创建的时候，this绑定在new创建的新对象上。 call、apply、bind是做什么的，有什么区别 改变this指向的。 call和apply的区别只在于传参形式不同，apply传入一个数组或类数组，call传入一个参数列表。 bind和其他两个区别在于，返回一个新函数，且不是立即执行的，需要手动执行。 什么是内存泄露，哪些操作会造成内存泄漏 内存泄漏指的是，没有使用也没有释放的内存。 比如： 闭包 循环引用 未使用的全局变量 被遗忘的定时器或回调函数 什么是事件代理，它的原理是什么 在父元素上设置事件，避免在需要多个同样事件的子元素上重复设置。 原理是：事件冒泡。 优点：减少内存空间，动态新增的元素不用重复绑定。 对AMD和CMD的理解，他们的区别都是模块化标准。 AMD-require.js-依赖前置，在定义模块的时候就要声明其依赖的模块 CMD-sea.js-就近依赖，需要某个模块的时候，再去require 对ES6的理解箭头函数有什么特点 本质是匿名函数 this指向定义时的对象，而不是调用时的对象。 不可以当作构造函数，不能用new，否则会抛出错误。 不能使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不适用于对象中的方法。 Promise对象的理解表现一个异步操作的最终状态，及其结果值。可以解决异步问题。 有三种状态：pending，fulfilled，rejected。 状态一旦确定，就不会再改变，随时可以获取。 状态不受外界因素影响。 新建后会立即执行。 可以用then指定resolve和reject的回调函数，返回一个promise对象。 可以实现链式调用，一个异步完成后，携带其返回值进入回调函数。 async函数和awit命令JS引擎执行机制的理解jQuery获取的dom对象和原生的dom对象有何区别js原生获取的dom是一个对象，jQuery对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。 jQuery如何扩展自定义方法12345678910(jQuery.fn.myMethod=function () &#123; alert('myMethod');&#125;)// 或者：(function ($) &#123; $.fn.extend(&#123; myMethod : function () &#123; alert('myMethod'); &#125; &#125;)&#125;)(jQuery) 使用： 1$("#div").myMethod(); 封装、继承、多态封装： 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 封装是面向对象的特征之一，是对象和类概念的主要特性。 一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。 在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。 继承： 让某个类型的对象获得另一个类型的对象的属性或方法。 支持按级分类的概念。 可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。 继承的过程，就是从一般到特殊的过程。 要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。 继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力； 多态： 一个类实例的相同方法在不同情形有不同表现形式。 多态机制使具有不同内部结构的对象可以共享相同的外部接口。 这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。 JS执行上下文执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念 执行上下文有三种 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。 Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端 - 面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见问题集锦]]></title>
    <url>%2F2019%2F07%2F06%2F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[HTMLDoctype作用，HTML5为什么只需要写&lt;!Doctype&gt; 标准通用标记语言的文档类型声明 告诉标准通用标记语言解析器，要使用什么样的文档类型定义（DTD）解析文档 必须是HTML文档的第一行，位于html标签之前 HTML5不基于SGML，所以不需要引用DTD。在HTML5中&lt;!DOCTYPE&gt;只有一种 SGML: 标准通用标记语言,是现时常用的超文本格式的最高层次标准 行内元素，块级元素，空元素 行内：a、span、select、b、i、strong、input、img等 块级：div、p、h1-h6、ul、ol、li、table等 空元素：br、hr、link、img、input、meta等 语义化理解 用合适的标签干合适的事情 有利于建立更清晰的HTML结构 便于SEO 有利于团队开发、维护 浏览器内核有哪些，及理解 内核 浏览器 Webkit Safari、Chrome（Chrome现在是Blink-Webkit的分支） Trident IE Gecko 火狐、Netscape6+ Presto Opera(原来是Presto，现在是Blink) 浏览器内核是浏览器最核心的部分，指渲染引擎（rendering engine）。 有时候我们所说的“浏览器内核”甚至“渲染引擎”，其实除了渲染引擎，也悄悄包含了js引擎，如WebKit，它由渲染引擎WebCore和javascript引擎JSCore组成。 不同的内核有不同的语法解析规则，导致同一个页面在不同浏览器下显示有差异，这就是网页为什么要兼容。 渲染引擎主要负责取得网页的内容、整理讯息、计算网页的显示方式等，JS引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果 H5有什么新特性 语义化标签: header footer nav section article aside 等 表单增强：date(从一个日期选择器选择一个日期) email(包含 e-mail 地址的输入域) number(数值的输入域) range(一定范围内数字值的输入域) search(用于搜索域) tel(定义输入电话号码字段) 等 视频和音频：audio video Canvas绘图 SVG绘图 地理定位：Geolocation 拖放API：drag web worker：是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能 web storage: localStorage sessionStorage WebSocket: HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议 cookie、sessionStorage 、localStorage 的区别 特性 Cookie localStorage sessionStorage 生命周期 可以设置，默认当前浏览器关闭后释放 除非手动清除，否则一直存在 仅在当前网页会话下有效，关闭页面或者浏览器就会被清除 存放数据 4kb左右 5mb 5mb HTTP请求 每次会携带在请求头中，使用过多会带来性能问题 仅在客户端保存，不参与服务器通信 仅在客户端保存，不参与服务器通信 实现浏览器多个标签页的通信 使用localStorage: localStorage.setItem(key,value)、localStorage.getItem(key) websocket协议 webworker： 提供一个额外的线程来执行一些js代码，并且不会影响到浏览器用户界面。 普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。 共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的。但必须保证这些标签页都是同源的(相同的协议，主机和端口号) HTML5的离线存储怎么使用，解释一下工作原理通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个manifest配置文件中，这样即使在离线的情况下，用户也可以正常使用App。 使用，在头部加入manifest属性即可： 1234&lt;!DOCTYPE HTML&gt;&lt;html manifest = "cache.manifest"&gt;...&lt;/html&gt; 然后cache.manifest文件的书写方式，就像下面这样： 12345678910111213CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 离线存储的manifest一般由三个部分组成: CACHE：表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 NETWORK：表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。 FALLBACK：表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。 工作原理 浏览器解析到html有manifest属性，则请求manifest文件 如果是第一次访问，将按文件内容下载离线资源 如果不是第一次，则使用离线资源加载页面 然后浏览器会对比新的manifest文件与旧的manifest文件 如果文件没有发生改变，就不做任何操作 如果文件改变了，那么就会重新下载文件中的资源并进行离线存储，如果中间某个下载失败，则仍然使用原离线资源 更新的资源需要到下次再打开app才会生效 如果需要资源马上就能生效，那么可以使用window.applicationCache.swapCache()方法来使之生效 src与href的区别 src表示引用资源，用于替代这个元素 href表示超文本引用，用于建立这个标签与外部资源之间的关系 link和@import的区别 link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 表单提交中Get和Post方式的区别 Get一般用于从服务器上获取数据，Post向服务器传送数据 Get传输的数据是拼接在Url之后的，对用户是可见的；Post的传输数据对用户是不可见的 Get传送的数据量较小，不能大于2KB。Post传送的数据量较大，一般被默认为不受限制 Get安全性非常低，Post安全性较高 在FORM提交的时候，如果不指定Method，则默认为Get请求 CSScss盒模型，box-sizing属性的理解css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。但盒子的大小由content+padding+border这几部分决定 box-sizing是一个CSS3属性，与盒子模型有着密切联系。即决定元素的宽高如何计算，box-sizing有三个属性： 1box-sizing: content-box|border-box|inherit: content-box 使得元素的宽高即为内容区的宽高(默认模式) border-box: 计算方式content + padding + border = 本身元素大小，即缩小了content大小 inherit 指定box-sizing属性的值，应该从父元素继承 清除浮动浮动的元素是脱离文档标准流的，如果我们不清楚浮动，那么就会造成父元素高度塌陷，影响页面布局。 清除浮动的方式： 为父元素设置高度 为父元素添加overflow:hidden 伪元素 12345.fix::after &#123; content:""; display:block; clear:both;&#125; 伪元素和伪类 伪类（pseudo-class） 是被添加到一个选择器末尾的关键字 前缀是一个冒号(:) 当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类 :active :hover :focus :nth-child() :only-child …… 伪元素（Pseudo-element） 是被添加到一个选择器末尾的关键字 前缀是两个冒号 (::) 添加到选择器后面去选择某个元素的某个部分。 ::after 创建一个伪元素，作为已选中元素的最后一个子元素::before 创建一个伪元素，其将成为匹配选中的元素的第一个子元素::first-letter 选中某块级元素第一行第一个字母，并且文字所处的行之前没有其他内容::first-line 选中某块级元素第一行::selection 应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）。::backdrop BFC、IFC、GFC 和 FFCFC：全称是：Formatting Contexts，是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 BFC(Block Formatting Contexts)块级格式化上下文 页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。 如何产生： float的值不为none。 overflow的值不为visible。 position的值不为relative和static。 display的值为table-cell, table-caption, inline-block中的任何一个。 IFC(Inline Formatting Contexts)内联格式化上下文 框(boxes)一个接一个地水平排列，起点是包含块的顶部。水平方向上的 margin，border 和 padding在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。 GFC(GridLayout Formatting Contexts)网格布局格式化上下文 元素获得一个独立的渲染区域，可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间 与table区别： 更加丰富的属性来控制行列，控制对齐 更为精细的渲染语义和控制 如何产生： display值为grid FFC(Flex Formatting Contexts)自适应格式化上下文 Flex Box 由伸缩容器和伸缩项目组成。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。（FLEX布局） 如何生成自适应容器（flex container）： display值为flex inline-flex的元素 如何让一个不定宽高的盒子水平垂直居中 定位 1234567891011.box &#123; position: relative;&#125;.child &#123; position: absolute; top: 0; bottom: 0; right: 0; left: 0; margin: auto;&#125; css3属性：transfrom 123456789.box &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; flex布局 12345.child &#123; display: flex; justify-content: center; align-items: center;&#125; px、em、rem的区别 px: 像素，相对长度单位。相对于显示器屏幕分辨率而言的 em的值并不是固定的，会继承父级元素的字体大小，代表倍数 rem的值并不是固定的，始终是基于根元素 &lt;html&gt; 的，也代表倍数 position的值有哪些 relative：相对定位 absolute：绝对定位 fixed：固定定位 static：默认，没有定位 display:none与visibility：hidden的区别 区别 display:none visibility:hidden 是否占据空间 不占据，在文档渲染时，该元素如同不存在（但依然存在文档对象模型树中） 占据 是否渲染 会触发reflow，进行渲染 会触发repaint。位置未发生改变，不渲染 是否继承 不是继承属性 是继承属性，若子元素使用了visibility:visible，则不继承，这个子孙元素又会显现出 什么是响应式设计，响应式设计的基本原理是什么 响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。 基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理 为什么要初始化CSS样式因为浏览器兼容性问题，对某些标签的默认渲染是不一样的，需要初始化CSS避免浏览器间页面差异。 初始化样式对SEO会有一定影响。 CSS3有哪些新特性 动画animation 过渡transition 媒体查询@media 多栏布局flex 实现旋转transform:rotate(90deg)，缩放scale(0.85,0.90)，translate(0px,-30px)定位，倾斜skew(-9deg,0deg) 实现圆角border-radius，阴影box-shadow，边框图片border-image 对文字加特效text-shadow，强制文本换行word-wrap，线性渐变linear-gradient 增加了更多的CSS选择器、多背景、rgba() 唯一引入的伪元素是::selection CSS优化、提高性能的方法有哪些 移除空的css规则（Remove empty rules） 正确使用display的属性 不滥用浮动、web字体 不声明过多的font-size 不在选择符中使用ID标识符 遵守盒模型规则 尽量减少页面重排、重绘 抽象提取公共样式，减少代码量]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise]]></title>
    <url>%2F2019%2F07%2F02%2Fpromise%2F</url>
    <content type="text"><![CDATA[概述Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。 本质上，Promise 是一个绑定了回调的对象，而不是将回调传进函数内部。 为什么使用处理异步请求的情况，在请求到的成功回调函数里继续写函数，长此以往形成了回调地狱。promise可以解决这种问题。 它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象 四种状态它存在四种状态： 已执行 - fulfilled - 与 promise 相关的操作成功 已拒绝 - rejected - 与 promise 相关的操作失败 待定 - pending -尚未执行或拒绝 已解决 - settled -已执行或拒绝，Promise 处于 fulfilled 或 rejected 二者中的任意一个状态, 不会是 pending 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 JavaScript 是单线程工作，这意味着两段脚本不能同时运行，而是必须一个接一个地运行。 在浏览器中，JavaScript 与因浏览器而异的其他 N 种任务共享一个线程。 但是通常情况下 JavaScript 与绘制、更新样式和处理用户操作（例如，高亮显示文本以及与格式控件交互）处于同一队列。 操作其中一项任务会延迟其他任务。 使用特点 在 本轮 Javascript event loop（事件循环）运行完成之前，callbacks（回调）是不会被调用的。 综上，通过.then() 形式添加的回调函数总会被调用，即便是在异步操作完成之后才被添加的函数。 通过多次调用 .then() ，可以添加多个回调函数，它们会按照插入顺序并且独立运行。 模板1234567var promise = new Pormise(function(resolve, reject)&#123; if()&#123; resolve(parmas)//异步操作成功传参 &#125; else &#123; reject(params)//异步操作失败传参 &#125;&#125;) resolve()函数将promise对象的状态从pending变为resolved，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。 reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 链式调用一个常见的需求就是连续执行两个或者多个异步操作，在上一个操作执行成功之后开始下一个的操作，并带着上一步操作所返回的结果。我们可以通过创造一个 Promise chain 来完成这种需求。 1const promise2 = doSomething().then(successCallback, failureCallback); 第二个对象(promise2)不仅代表doSomething()函数的完成，也代表了你传入的 successCallback 或者failureCallback 的完成，successCallback 或 failureCallback有可能返回一个Promise对象从而形成另一个异步操作。这样的话，任何一个 promise2 新增的回调函数都会被依次排在由上一个successCallback(成功回调函数) 或 failureCallback(失败回调函数) 执行后所返回的 Promise对象的后面。 基本上，每一个 Promise 代表了链式中另一个异步过程的完成。 Promise.prototype.then()Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 then里的参数是可选的，catch(failureCallback) 是 then(null, failureCallback) 的缩略形式。 then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。 注意：一定要有返回（即 需要 return ），否则 callback 无法获取上个 Promise 的结果。(使用 () =&gt; x 比() =&gt; { return x; } 更简洁一点). 1234567p.then(onFulfilled, onRejected);p.then(function(value) &#123; // fulfillment &#125;, function(reason) &#123; // rejection&#125;); 如果忽略针对某个状态的回调函数参数，或者提供非函数 (nonfunction) 参数，那么 then 方法将会丢失关于该状态的回调函数信息，但是并不会产生错误。 如果调用 then的 Promise 的状态（fulfillment 或 rejection）发生改变，但是 then 中并没有关于这种状态的回调函数，那么 then 将创建一个没有经过回调函数处理的新 Promise 对象，这个新 Promise 只是简单地接受调用这个 then 的原 Promise 的终态作为它的终态。 1234567891011121314151617181920212223242526272829 function foo() &#123; var p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout( () =&gt; &#123; console.log('setTimeout'); //resolve('test'); reject('error'); &#125;,2000 ) &#125;) return p1; &#125;var p = foo().then((data) =&gt; console.log(data),() =&gt; console.log('fail'));var p2 = p.then(() =&gt; console.log('last block'));var p3 = p2.then( () =&gt; &#123; var p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout( () =&gt; &#123; console.log('setTimeout'); resolve('test');//如果当前返回的是成功状态，catch不进行打印 //reject('error');//如果当前返回的是失败状态，catch打印 &#125;,2000 ) &#125;) return p1; &#125;).catch(() =&gt; console.log('catch block')); Promise.prototype.catch()很可能会在一个回调失败之后继续使用链式操作，即 使用一个catch，这对于在链式操作中抛出一个失败之后，再次开启新的操作很有用。 Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 (事实上, calling obj.catch(onRejected) 内部calls obj.then(undefined, onRejected)). 12345p.catch(onRejected);p.catch(function(reason) &#123; // 拒绝&#125;); onRejected 当Promise 被rejected时，被调用的一个Function。 该函数拥有一个参数： reason ：rejection 的原因。 如果 onRejected 抛出一个错误或返回一个本身失败的 Promise ，通过 catch() 返回的Promise 被rejected；否则，它将显示为成功（resolved）。 返回值：一个Promise。 可以用于捕获异常： 1234567var c = foo().then( data =&gt; &#123; throw "I'm a error!"//抛出异常 resolve(data);//如果resolve在throw之前，则异常不会被抛出 &#125; ) .catch(() =&gt; console.log('error'))//error 已决议情况下： 12345678910111213141516//创建一个新的 Promise ，且已决议var p1 = Promise.resolve("calling next");var p2 = p1.catch(function (reason) &#123; //这个方法永远不会调用 console.log("catch p1!"); console.log(reason);&#125;);p2.then(function (value) &#123; console.log("next promise's onFulfilled"); /* next promise's onFulfilled */ console.log(value); /* calling next */&#125;, function (reason) &#123; console.log("next promise's onRejected"); console.log(reason);&#125;); Promise.prototype.finally()返回一个Promise。 在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。 这避免了同样的语句需要在then()和catch()中各写一次的情况。 12345p.finally(onFinally);p.finally(function() &#123; // 返回状态为(resolved 或 rejected)&#125;); onFinally：Promise 结束后调用的Function。 Promise.all()Promise.all(iterable) 方法返回一个 Promise实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。 1Promise.all(iterable); iterable：一个可迭代对象，如 Array或 String。 返回值： 如果传入的参数是一个空的可迭代对象，则返回一个已完成（already resolved）状态的 Promise。 如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。注意：Google Chrome 58 在这种情况下返回一个已完成（already resolved）状态的 Promise。 其它情况下返回一个处理中（pending）的Promise。这个返回的 promise 之后会在所有的 promise 都完成或有一个 promise 失败时异步地变为完成或失败。返回值将会按照参数内的 promise 顺序排列，而不是由调用 promise 的完成顺序决定。 如果传入的 promise 中有一个失败（rejected），Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成。 Promise.allSeteled()返回一个promise，该promise在所有给定的promise已被解析或被拒绝后解析，并且每个对象都描述每个promise的结果。 1p.allSettled（iterable）; iterable：一个可迭代对象，如 Array或 String，其中每个成员都是Promise。 返回值：一个悬而未决 Promise将被异步完成一次承诺的指定集合在每一个承诺已经完成，无论是成功的达成或通过被拒绝。那时，返回的promise的处理程序作为输入传递一个数组，该数组包含原始promises集中每个promise的结果。 如果传参的状态都变成fulfilled，p的状态才会变成fulfilled，此时返回值组成一个数组，传递给p的回调函数。 如果传参之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.race()返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。 1Promise.race(iterable); iterable：可迭代对象，类似Array。详见 iterable。 返回值：一个待定的 Promise只要给定的迭代中的一个promise解决或拒绝，就采用第一个promise的值作为它的值，从而异步地解析或拒绝（一旦堆栈为空） Promise.resolve()将现有对象转为 Promise 对象。 如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled） 如果传入的value本身就是promise对象，则该对象作为Promise.resolve方法的返回值返回 否则以该值为成功状态返回promise对象 Promise.reject()返回一个带有拒绝原因reason参数的Promise对象。 1Promise.reject(reason); reason：表示Promise被拒绝的原因。 返回值：一个给定原因了的被拒绝的 Promise。 应用加载东西，加载成功改变状态，如加载图片 相关问题介绍PromisePromise是一种用于解决异步问题的思路、方案或者对象方式。 Promise有几个状态 四种状态 pending(待定)、fulfulled(已执行)、rejected(已拒绝)、settled(已解决) promise的特性，以及优缺点特点： 对象的状态不受外界影响 一旦状态改变，就不会再变，任何时候都可以得到这个结果 Promise 新建后就会立即执行 缺点： 当处于未完成状态时，无法确定目前处于哪一阶段。 如果不设置回调函数，Promise内部的错误不会反映到外部。 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 Promise如何实现的在Promise的内部，有一个状态管理器的存在，有三种状态：pending、fulfilled、rejected。 (1) promise 对象初始化状态为 pending。 (2) 当调用resolve(成功)，会由pending =&gt; fulfilled。 (3) 当调用reject(失败)，会由pending =&gt; rejected。 因此，看上面的的代码中的resolve(num)其实是将promise的状态由pending改为fulfilled，然后向then的成功回掉函数传值，reject反之。但是需要记住的是注意promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变（记住，一定要记住，下面会考到）。 当状态为fulfilled（rejected反之）时，then的成功回调函数会被调用，并接受上面传来的num，进而进行操作。promise.then方法每次调用，都返回一个新的promise对象 所以可以链式写法（无论resolve还是reject都是这样）。 Promise和setTimeout的区别（Event Loop）Promise先执行，settimeout后执行。 事件轮询执行顺序。 Promise 和 async/await 和 Callback的区别callback 回调函数实际就是一个参数 先处理本体函数，再处理回调的函数 promise 代码组织形式更加易读 异常处理方式更好 本质还是callback async/await Async/await 是建立在 Promises上的，不能被使用在普通回调以及节点回调 async函数返回一个promise对象，如果在async函数中返回一个直接量，async会通过Promise.resolve封装成Promise对象。我们可以通过调用promise对象的then方法，获取这个直接量。 Async/await 和 Promises 很像，不阻塞 使用 async/await，可以让异步编程的呈现更加简洁直观，看起来像同步代码 async/await 是对 Promise 的链式结构上进行的改进，使用 async/await 不能离开 Promise。 async/await 本身不提供并行执行的能力，因此，在 JS 中进行异步操作并行执行还是要使用Promise.all()或者将多个Promise.then()单独使用 Promise有没有解决异步的问题（Promise链是真正强大的地方）异常捕获Promise.all实现原理介绍Promise和thenPromise如何实现Then处理Promise里面和then里面执行有什么区别Promise构造函数是同步还是异步执行，then呢相关代码题1.123456789const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1); resolve(); console.log(2);&#125;);promise.then(() =&gt; &#123; console.log(3);&#125;);console.log(4);复制代码 输出结果为：1，2，4，3。 解题思路：then方法是异步执行的。 2.1234567891011const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success') reject('error') &#125;, 1000)&#125;)promise.then((res)=&gt;&#123; console.log(res)&#125;,(err)=&gt;&#123; console.log(err)&#125;) 输出结果：success 解题思路：Promise状态一旦改变，无法在发生变更。 3.1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 输出结果：1 解题思路：Promise的then方法的参数期望是函数，传入非函数则会发生值穿透。 4.1234567891011setTimeout(()=&gt;&#123; console.log('setTimeout')&#125;)let p1 = new Promise((resolve)=&gt;&#123; console.log('Promise1') resolve('Promise2')&#125;)p1.then((res)=&gt;&#123; console.log(res)&#125;)console.log(1) 输出结果： Promise1 1 Promise2 setTimeout 解题思路：这个牵扯到js的执行队列问题，整个script代码，放在了macrotask queue中，执行到setTimeout时会新建一个macrotask queue。但是，promise.then放到了另一个任务队列microtask queue中。script的执行引擎会取1个macrotask queue中的task，执行之。然后把所有microtask queue顺序执行完，再取setTimeout所在的macrotask queue按顺序开始执行。（具体参考www.zhihu.com/question/36…） ​ 宏任务同步任务 -&gt; 微任务 -&gt; 宏任务异步任务 5.1234567891011Promise.resolve(1) .then((res) =&gt; &#123; console.log(res); return 2; &#125;) .catch((err) =&gt; &#123; return 3; &#125;) .then((res) =&gt; &#123; console.log(res); &#125;);复制代码 输出结果：1 2 解题思路：Promise首先resolve(1)，接着就会执行then函数，因此会输出1，然后在函数中返回2。因为是resolve函数，因此后面的catch函数不会执行，而是直接执行第二个then函数，因此会输出2。 6.123456789101112131415const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('开始'); resolve('success'); &#125;, 5000);&#125;); const start = Date.now();promise.then((res) =&gt; &#123; console.log(res, Date.now() - start);&#125;); promise.then((res) =&gt; &#123; console.log(res, Date.now() - start);&#125;); 输出结果： 开始 success 5002 success 5002 解题思路：promise 的.then或者.catch可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用.then 或者.catch都会直接拿到该值。 7.1234567891011121314151617181920212223242526272829303132let p1 = new Promise((resolve,reject)=&gt;&#123; let num = 6 if(num&lt;5)&#123; console.log('resolve1') resolve(num) &#125;else&#123; console.log('reject1') reject(num) &#125;&#125;)p1.then((res)=&gt;&#123; console.log('resolve2') console.log(res)&#125;,(rej)=&gt;&#123; console.log('reject2') let p2 = new Promise((resolve,reject)=&gt;&#123; if(rej*2&gt;10)&#123; console.log('resolve3') resolve(rej*2) &#125;else&#123; console.log('reject3') reject(rej*2) &#125; &#125;) return p2&#125;).then((res)=&gt;&#123; console.log('resolve4') console.log(res)&#125;,(rej)=&gt;&#123; console.log('reject4') console.log(rej)&#125;) 输出结果： reject1 reject2 resolve3 resolve4 12 解题思路：我们上面说了Promise的先进之处在于可以在then方法中继续写Promise对象并返回。 8.重头戏！！！！实现一个简单的Promise12345678910111213141516171819202122232425262728293031323334function Promise(fn)&#123; var status = 'pending' function successNotify()&#123; status = 'fulfilled'//状态变为fulfilled toDoThen.apply(undefined, arguments)//执行回调 &#125; function failNotify()&#123; status = 'rejected'//状态变为rejected toDoThen.apply(undefined, arguments)//执行回调 &#125; function toDoThen()&#123; setTimeout(()=&gt;&#123; // 保证回调是异步执行的 if(status === 'fulfilled')&#123; for(let i =0; i&lt; successArray.length;i ++) &#123; successArray[i].apply(undefined, arguments)//执行then里面的回掉函数 &#125; &#125;else if(status === 'rejected')&#123; for(let i =0; i&lt; failArray.length;i ++) &#123; failArray[i].apply(undefined, arguments)//执行then里面的回掉函数 &#125; &#125; &#125;) &#125; var successArray = [] var failArray = [] fn.call(undefined, successNotify, failNotify) return &#123; then: function(successFn, failFn)&#123; successArray.push(successFn) failArray.push(failFn) return undefined // 此处应该返回一个Promise &#125; &#125;&#125; 解题思路：Promise中的resolve和reject用于改变Promise的状态和传参，then中的参数必须是作为回调执行的函数。因此，当Promise改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>promise - JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bind、apply、call]]></title>
    <url>%2F2019%2F07%2F02%2Fbind%2F</url>
    <content type="text"><![CDATA[概述JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。 call、apply、bind都是用来改变this指向的，但是他们存在一些差异： call和applycall 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 callcall() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 1fun.call(thisArg, arg1, arg2, ...) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数在非严格模式下运行，则指定为 null 和 undefined 的 this 值会自动指向全局对象（浏览器中就是 window 对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 arg1, arg2, …：指定的参数列表。 call() 允许为不同的对象分配和调用属于一个对象的函数/方法。 call() 提供新的 this 值给当前调用的函数/方法。你可以使用 call 来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。 applyapply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 1fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。 用 apply 将数组添加到另一个数组 1234var array = ['a', 'b'];var elements = [0, 1, 2];array.push.apply(array, elements);console.info(array); // ["a", "b", 0, 1, 2] call和apply只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。 bind bind有什么用？ bind() 方法调用后会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为新函数运行时的 this的值，之后的序列参数将会在传递的实参前传入作为新函数的参数。 bind挂在Function的原型上 Function.prototype.bind 创建的函数都可以调用bind 1function.bind(thisArg[, arg1[, arg2[, ...]]]) thisArg：调用绑定函数时作为this参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用bind在setTimeout中创建一个函数（作为回调提供）时，作为thisArg传递的任何原始值都将转换为object。如果bind函数的参数列表为空，执行作用域的this将被视为新函数的thisArg。 arg1, arg2, …：当目标函数被调用时，预先添加到绑定函数的参数列表中的参数。 返回值：返回一个原函数的拷贝，并拥有指定的this值和初始参数。 bind和call、apply的区别是，bind返回一个新函数，不会马上执行，需要手动调用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>this - JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的this指向]]></title>
    <url>%2F2019%2F07%2F02%2Fthis%2F</url>
    <content type="text"><![CDATA[概述 this是什么？ 它是JS关键字，在JS中具有特殊意义，代表一个空间地址； 上下文对象就是 this 指针,即被调用函数所处的环境。 this不会指向？ 不会指向作用域 将包含this的函数，作为属性储存的对象，并不认为是this所指代的对象 this最初被定义的对象或函数，也不一定是this指代的内容 绑定规则this的指向主要看函数的调用位置，绑定规则总共有下面5种。 1、默认绑定 严格模式：绑定undefined 非严格模式：绑定全局 2、隐式绑定绑定到当前上下文对象12345678function foo() &#123; console.log(this.a)//1&#125;var obj = &#123; a: 1, foo: foo//在此隐式绑定&#125;obj.foo(); 特定情况下会丢失绑定对象123456789function foo() &#123; console.log(this.a)//报错，a is not defined&#125;var obj = &#123; a: 1, foo: foo//在此隐式绑定&#125;var b = obj.foo;//此处b相当于直接指向foo函数，而不是obj.foo()b();//这样调用就会丢失绑定对象，this指向全局 参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。回调函数丢失this绑定是非常常见的。 1234567891011function foo() &#123; console.log(this.a)//报错，a is not defined&#125;function foo1(fn) &#123; fn();//实际调用位置&#125;var obj = &#123; a: 1, foo: foo&#125;foo1(obj.foo); 3、显式绑定通过call()或apply()，第一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定。 1234567function foo() &#123; console.log(this.a)//1&#125;var obj = &#123; a: 1&#125;foo.call(obj);//显式绑定 call()、apply()显示绑定无法解决丢失绑定问题 丢失绑定解决办法硬绑定创建函数bar()，并在它的内部手动调用foo.call(obj)，强制把foo的this绑定到了obj。 bind()会返回一个硬绑定的新函数 API调用的“上下文”，JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。 4、new绑定new的过程？使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 1、创建（或者说构造）一个新对象。 2、这个新对象会被执行[[Prototype]]连接。 3、这个新对象会绑定到函数调用的this。 4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 传入Null把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认规则。 下面两种情况下会传入null 使用apply(..)来“展开”一个数组，并当作参数传入一个函数 bind(..)可以对参数进行柯里化（预先设置一些参数） 副作用总是传入null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。 副作用解决办法传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。 JS中创建一个空对象最简单的方法是Object.create(null)，这个和{}很像，但是并不会创建Object.prototype这个委托，所以比{}更空。 12345678910111213function foo(a, b) &#123; console.log( "a:" + a + "，b:" + b );&#125;// 我们的空对象var ø = Object.create( null );// 把数组”展开“成参数foo.apply( ø, [2, 3] ); // a:2，b:3// 使用bind(..)进行柯里化var bar = foo.bind( ø, 2 );bar( 3 ); // a:2，b:3 间接引用间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生 1234567891011// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()function foo() &#123; console.log( this.a );&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;;var p = &#123; a: 4&#125;;o.foo(); // 3(p.foo = o.foo)(); // 2 软绑定 硬绑定可以把this强制绑定到指定的对象（new除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改this。 如果给默认绑定指定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。 123456789101112131415// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改thisif (!Function.prototype.softBind) &#123; Function.prototype.softBind = function (obj) &#123; var fn = this; var curried = [].slice.call(arguments, 1); var bound = function () &#123; return fn.apply( ( !this || this === (Window || global) ? obj : this, curried.concat.apply(curried, arguments) ); &#125;; bound.prototype = Object.create(fn.prototype); return bound; &#125;&#125; 5、箭头函数绑定箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（词法作用域）来决定this。 箭头函数不绑定this，箭头函数中的this相当于普通变量。 箭头函数的this寻值行为与普通变量相同，在作用域中逐级寻找。 箭头函数的this无法通过bind，call，apply来直接修改（可以间接修改）。 改变作用域中this的指向可以改变箭头函数的this。 eg. function closure(){()=&gt;{//code }}，在此例中，我们通过改变封包环境closure.bind(another)()，来改变箭头函数this的指向。 foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar(引用箭头函数)的this也会绑定到obj1，箭头函数的绑定无法被修改(new也不行)。 123456789101112131415161718function foo() &#123; // 返回一个箭头函数 return (a) =&gt; &#123; // this继承自foo() console.log( this.a ); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;var bar = foo.call( obj1 );bar.call( obj2 ); // 2，不是3！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>this - JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柯里化函数]]></title>
    <url>%2F2019%2F07%2F01%2Fcurry-function%2F</url>
    <content type="text"><![CDATA[概念柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 由以上定义，柯里化又可理解为部分求值，返回接受剩余参数且返回结果的新函数。想要应用柯里化，我们必须先理解柯里化的作用和特点，这里我总结为以下三点： 参数复用 – 复用最初函数的第一个参数 提前返回 – 返回接受余下的参数且返回结果的新函数 延迟执行 – 返回新函数，等待执行 如: 12345function curry(fn, ..args) &#123; return (..._arg) =&gt; &#123; return fn(...args, ..._arg); &#125;&#125; 我们在这里做了什么？ 我们的curry函数接受一个我们想要柯里化的函数（fn）和一个变量（...args）。这里的rest操作符用来将参数聚集成一个...args。接下来我们返回一个函数，该函数将其余参数收集为..._args。此函数通过spread运算符将... args和..._args作为参数解构传入来调用原始函数fn，然后将值返回给用户。 实际运用当一个函数需要提前处理并需要等待执行或者接受多个不同作用的参数时候，我们便可应用柯里化。 编写可以复用和配置的小代码块举个例子，你有一家商店，然后你想给你的优惠顾客10%的折扣： 123function discount(pirce, discount) &#123; return pirce*discount&#125; 当一个优惠顾客消费了500元，你会给他： 1const price = discount(500, 0.10); 这样的话，每次我们计算折扣时都需要额外计算10%的折扣。所以我们可以将函数柯里化： 123456function discount(discount) &#123; return (price) =&gt; &#123; return price * discount; &#125;&#125;const tenPercentDiscount = discount(0.1); 现在，我们只需用商品价格来计算就可以了： 1tenPercentDiscount(500); 当优惠系数改变时，我们只用调整discount的传参： 12const twentyPercentDiscount = discount(0.2);twentyPercentDiscount(500); 事件监听原生事件监听的方法在现代浏览器和IE浏览器会有兼容问题，解决该兼容性问题的方法是进行一层封装，若不考虑柯里化函数，我们正常情况下会像下面这样进行封装，如下： 12345678910111213141516/** @param ele Object DOM元素对象* @param type String 事件类型* @param fn Function 事件处理函数* @param isCapture Boolean 是否捕获*/var addEvent = function(ele, type, fn, isCapture) &#123; if(window.addEventListener) &#123; ele.addEventListener(type, fn, isCapture) &#125; else if(window.attachEvent) &#123; ele.attachEvent("on" + type, fn) &#125;&#125; 该封装方法完全没有问题，但是有个唯一的缺陷就是，当我们每次调用addEvent方法时，都会执行一次if...else if...，进行一次兼容判断。其实每次都执行兼容判断是完全没有必要的，那有没有办法只做一次判断呢？这个时候，柯里化函数就派上用场了，如下： 1234567891011var addEvent = (function() &#123; if(window.addEventListener) &#123; return function(ele, type, fn, isCapture) &#123; ele.addEventListener(type, fn, isCapture) &#125; &#125; else if(window.attachEvent) &#123; return function(ele, type, fn) &#123; ele.attachEvent("on" + type, fn) &#125; &#125;&#125;)() 这个例子利用了柯里化提前返回和延迟执行的特点，如下： 提前返回 – 使用函数立即调用进行了一次兼容判断（部分求值），返回兼容的事件绑定方法 延迟执行 – 返回新函数，在新函数调用兼容的事件方法。等待addEvent新函数调用，延迟执行 这就是柯里化函数的基本用法 – 提前返回和延迟执行，但是这里没有利用到柯里化参数复用的特点。 防抖和节流在web开发中，页面高频率触发的事件非常多，例如scroll,resize,mousemove等等，但是浏览器页面渲染的帧频为60fps，意思就是每秒刷新60帧，每1000/60约等于16.7ms刷新一次帧。 但当事件触发频率大于浏览器的显示频率(16.7ms/帧)时，即浏览器显示跟不上事件触发的频率，若事件处理函数中涉及DOM操作，则会导致浏览器掉帧，继而导致动画断续显示，画面粘滞，在很大程度上影响用户体验，严重时则会使浏览器CPU使用率不断增加，继而造成浏览器卡顿甚至崩溃。 这时我们需要做一些控制及处理： 高频事件处理函数，不应该含有复杂的操作，例如DOM操作和复杂计算（DOM操作一般会造成页面回流和重绘，使浏览器不断重新渲染页面）。 控制高频事件的触发频率 如果我们能延迟事件处理函数的执行，那么就相当于控制了事件的触发频率，然后再通过保存执行状态来控制事件处理函数的执行，那么整个问题就可以迎刃而解了。 其中防抖和节流对高频事件进行优化的原理就是通过延迟执行，将多个间隔接近的函数执行合并成一次函数执行。下面将会详细讲解。 防抖针对高频事件，防抖就是将多个触发间隔接近的事件函数执行，合并成一次函数执行。 实现防抖的关键点主要有两个，如下： 使用setTimeout延时器，传入的延迟时间，将事件处理函数延迟执行，并且通过事件触发频率与延迟时间值的比较，控制处理函数是否执行 使用柯里化函数结合闭包的思想，将执行状态保存在闭包中，返回新函数，在新函数中通过执行状态控制是否在滚动时执行处理函数 实现代码如下： 1234567891011121314151617181920212223242526272829/** @param fn Function 事件处理函数* @param delay Number 延迟时间* @param isImmediate Boolean 是否滚动时立刻执行* @return Function 事件处理函数*/var debounce = function(fn, delay, isImmediate) &#123; //使用闭包，保存执行状态，控制函数调用顺序 var timer;//在retur语句前面设置变量用来存储最后的setTimeout return function() &#123; var _args = [].slice.call(arguments), context = this;// 通过 ‘this’ 和 ‘arguments’ 获取函数的作用域和变量 clearTimeout(timer);//每次调用之前先清空定时器 var _fn = function() &#123; timer = null; if (!isImmediate) fn.apply(context, _args); &#125;; //是否滚动时立刻执行 var callNow = !timer &amp;&amp; isImmediate; timer = setTimeout(_fn, delay); if(callNow) fn.apply(context, _args); &#125;&#125; setTimeout定时器的返回值是一个唯一的数值，如果你想要终止setTimeout()方法的执行，那就必须使用 clearTimeout()方法来终止，而使用这个方法的时候，系统必须知道你到底要终止的是哪一个setTimeout()方法(因为你可能同时调用了好几个 setTimeout()方法)，这样clearTimeout()方法就需要一个参数，这个参数就是setTimeout()方法的返回值(数值)，用这个数值来唯一确定结束哪一个setTimeout()方法。 防抖技术使用如下： 123456var debounceScroll = debounce(function() &#123; //事件处理函数，滚动时进行的处理&#125;, 100)window.addEventListener("scroll", debounceScroll) 防抖技术仅靠传入延迟时间值的大小控制高频事件的触发频率，如果传入的延迟时间值比较大，那么就会出现一定的问题。例如当传入延迟时间为1000ms，那么当用户滚动速度大于1000ms/次时，则无论鼠标滚动多久都不会触发事件处理函数。因此防抖技术存在一定的缺陷，会不适用于某些场景，例如图片懒加载。这个时候节流就派上用场了。 节流节流也是将多个触发间隔接近的事件函数执行，合并成一次函数执行，并且在指定的时间内至少执行一次事件处理函数。 节流实现原理跟防抖技术类似，但是比防抖多了一次函数执行判断，实现的关键点是： 利用闭包存储了当前和上一次执行的时间戳，通过两次函数执行的时间差跟指定的延迟时间的比较，控制函数是否立刻执行 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536/** @param fn Function 事件处理函数* @param wait Number 延迟时间* @return Function 事件处理函数*/var throttle = function(fn, wait) &#123; var timer, previous, now, diff; return function() &#123; var _args = [].slice.call(arguments), context = this; //储存当前时间戳 now = Date.now(); var _fn = function() &#123; //存储上一次执行的时间戳 previous = Date.now(); timer = null; fn.apply(context, _args) &#125; clearTimeout(timer) if(previous !== undefined) &#123; //时间差 diff = now - previous; if(diff &gt;= wait) &#123; fn.apply(context, _args); previous = now; &#125; else &#123; timer = setTimeout(_fn, wait); &#125; &#125;else&#123; _fn(); &#125; &#125;&#125; 注：以上防抖和节流函数封装是根据个人理解进行封装的，若想对比不同的封装方法，建议阅读第三方underscore函数库中的throttle和debounce的实现方法，原理大致是一样的，但是封装思维稍有不同。 拓展： 以上的节流和防抖技术都是用setTimeout实现的，是否有其他的实现方案，性能是否会更好？ 可直接使用浏览器帧频刷新自动调用的方法(requestAnimationFrame)实现，实现起来会更加简单，而且性能会更好，但是唯一缺点就是需要自行解决低版本的IE浏览器兼容问题，实现代码如下： 1234567891011121314151617181920212223242526//解决requestAnimationFrame兼容问题var raFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) &#123; window.setTimeout(callback, 1000 / 60); &#125;;//柯里化封装var rafThrottle = function(fn) &#123; var isLocked; return function() &#123; var context = this, _args = arguments; if(isLocked) return isLocked = true; raFrame(function() &#123; isLocked = false; fn.apply(context, _args) &#125;) &#125;&#125; bind函数柯里化函数的bind方法相信我们都不陌生，但是低版本的IE浏览器不兼容bind方法，想要继续在低版本的IE浏览器中使用bind方法，则需要我们自行封装bind方法，实现的关键点是： bind方法改变this指向，却不会执行原函数，那么我们可利用柯里化延迟执行，参数复用和提前返回的特点，返回新函数，在新函数使用apply方法执行原函数 我们这里将bind方法封装分为两种情况，如下： 第一种：简单的bind方法封装（不考虑构造函数，仅用于普通函数），实现代码如下： 12345678910111213141516if (!Function.prototype.bind) &#123; Function.prototype.bind = function(context) &#123; if(context.toString() !== "[object Object]" &amp;&amp; context.toString() !== "[object Window]" ) &#123; throw TypeError("context is not a Object.") &#125; var _this = this; var args = [].slice.call(arguments, 1); //表示取当前作用域中传的参数中除了context以外后面的参数； return function() &#123; var _args = [].slice.call(arguments);//表示取当前作用域中所有的arguments参数 _this.apply(context, _args.concat(args)) &#125; &#125;&#125; 第二种：复杂情况（考虑bind的任何用法），这里直接使用MDN的bind兼容方法，如下： 1234567891011121314151617181920212223242526272829if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() &#123;&#125;, fBound = function() &#123; return fToBind.apply(this instanceof fNOP ? this : oThis, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; // 维护原型关系 if (this.prototype) &#123; // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; &#125; fBound.prototype = new fNOP(); return fBound; &#125;;&#125;; 要理解复杂的bind兼容方法，必须彻底理解以下四个基础知识： js的原型对象 构造函数使用new操作符的过程 this的指向问题 熟悉bind方法的使用场景 围绕以上四个关键点思考，bind的封装思想便可理解，这里不做过多解释。 柯里化函数封装部分求值，将复杂问题分步求解，变得更简单化 我们可以尝试封装一个简单的柯里化函数，如下： 1234567891011121314function createCurry(fn) &#123; if(typeof fn !== "function")&#123; throw TypeError("fn is not function."); &#125; //复用第一个参数 var args = [].slice.call(arguments, 1); //返回新函数 return function()&#123; //收集剩余参数 var _args = [].slice.call(arguments); //返回结果 return fn.apply(this, args.concat(_args)); &#125;&#125; 柯里化函数的特点如上注释所示： 复用第一个参数 返回新函数 收集剩余参数 返回结果 柯里化函数的简单例子应用，如下： 12345678910111213//add(19)(10, 20, 30)，求该函数传递的参数和var add = createCurry(function() &#123; //获取所有参数 var args = [].slice.call(arguments); //返回累加结果 return args.reduce(function(accumulator, currentValue) &#123; return accumulator + currentValue &#125;)&#125;, 19)add(10, 20, 30); //79 参考资料： 柯里化函数应用 [翻译]JavaScript中的柯里化（Currying in JavaScript）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端 - JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存机制（HTTP缓存机制）]]></title>
    <url>%2F2019%2F06%2F30%2Fbrowser-cache%2F</url>
    <content type="text"><![CDATA[有时候，我们会看见请求资源会出现memory cache和disk cache这种标识，这就意味着当前资源数据是从缓存中拿取的。 为什么使用缓存 减少网络带宽消耗 降低服务器压力 减少网络延迟，加快页面打开速度 概述浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的。 我们知道HTTP报文格式为： 请求行 缓存优先级缓存位置分为四种，且优先级不同，当依次查找都没有命中时，再去请求服务端。 Service Worker 运行在浏览器背后的独立线程 使用 Service Worker的话，传输协议必须为 HTTPS Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存 并且缓存是持续性的。 Memory cache 内存中的缓存 直接将缓存写入硬盘文件中 读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容 读取复杂，速度比内存缓存慢 Disk cahce 硬盘中的缓存 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 Push cache 推送缓存（HTTP/2.0） 会话（Session）中存在 一旦会话结束就被释放，并且缓存时间也很短暂 通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 浏览器读取缓存的顺序为memory –&gt; disk。 强制缓存强制缓存，就是在浏览器缓存中查找需要的资源，并根据查找结果来决定是否使用该缓存结果的过程。更关心缓存的新鲜度（过期机制），即缓存有效期。 强制缓存的查找结果分为三种情况： 不存在该缓存结果和缓存标识，强制缓存失败，直接向服务器发送HTTP请求来查找资源。 存在缓存结果和缓存标识，但缓存结果过期，强制缓存失败，转用协商缓存。 存在缓存结果和缓存标识，缓存结果未失效，强制缓存生效，返回该结果。 强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。 expires其值为服务器返回该请求结果，这个结果到期的时间。是一个绝对值。 由于客户端和服务端时间上有可能存在差异，因此expires不够准确，在HTTP/1.1中背Cache-Control代替。 Cache-Control在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为： public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，Cache-Control的默认取值 no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效，是一个相对值 两者同时存在的话，Cache-Control优先级高于Expires 协商缓存协商缓存，在强制缓存失效且存在缓存结果和缓存标识时使用，携带缓存标识请求服务器，查看该资源是否发生变更，是否使用缓存的过程。更关心缓存校验值（验证机制），即是否发生更新。 协商缓存存在两种情况： 根据缓存标识，服务器发现资源未进行变更，则返回304，协商缓存生效，使用强制缓存的结果。 根据缓存标识，服务器发现资源变更，则返回200和请求结果，使用返回结果并将其存入浏览器缓存中，协商缓存失效。 Last-Modified / If-Modified-SinceLast-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间 If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件 Etag / If-None-MatchEtag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成) If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200 首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag 过程 用户操作对缓存的影响 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。 用户操作 Expires/Cache-Control Last-Modified/Etag 地址栏回车 √ √ 页面链接跳转 √ √ 新开窗口 √ √ 前进、后退 √ √ F5刷新 无效(BR重置max-age=0) √ Ctrl+F5刷新 无效（重置Cache-Control=no-cache） 无效（请求头丢弃该选项]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>缓存 - HTTP</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F28%2Finterview%2F</url>
    <content type="text"><![CDATA[HTML&lt;a&gt;标签默认事件禁掉之后做了什么才实现了跳转Cookie放哪里，Cookie能做的事情和存在的价值Cookie和Session有哪些方面的区别Key主要是解决哪一类的问题，为什么不建议用索引index（重绘）如何设计一个localStorage，保证数据的实效性CSS介绍Flex布局其他CSS方式设置垂直居中居中为什么要使用Transform（为什么不使用MarginLeft/Top）介绍position属性包括CSS3新增清除浮动定位问题（绝对定位、相对定位等）JSJS执行上下文执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念 执行上下文有三种 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。 Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用。 new是怎么实现的JS里垃圾回收机制是什么，常用的是哪种，怎么处理的JS变量类型分为几种，区别是什么怎么实现this对象的深拷贝文件上传如何做断点续传搜索请求如何处理（防抖）介绍This各种情况前端怎么控制管理路由== 和 ===的区别，什么情况下用相等==Bind、Call、Apply的区别介绍下原型链（解决的是继承问题吗）介绍暂时性死区介绍纯函数介绍虚拟DOM介绍高阶组件两个对象如何比较some、every、find、filter、map、forEach有什么区别ES6中的Map和原生的对象有什么区别对闭包的看法，为什么要用闭包设计模式有哪些设计模式介绍观察者模式介绍中介者模式观察者和订阅-发布的区别，各自用在哪里请求如何解决跨域的问题表单可以跨域吗常见Http请求头对Async、Await的理解，内部原理介绍Promise，异常捕获Promise有几个状态Ajax发生跨域要设置什么（前端）使用Async会注意哪些东西Promise、Async有什么区别介绍Http2.0如何设计Promise.all()测试前端怎么做单元测试工具Webpack里面的插件是怎么实现的使用import时，Webpack对node_modules里的依赖会做什么Webpack整个生命周期，Loader和Plugin有什么区别Webpack打包的整个过程常用的Plugins一般怎么组织CSS（Webpack）前端和后端怎么联调优化项目优化整个前端性能提升大致分几类抽取公共文件是怎么配置的网站SEO怎么处理说说从输入URL到看到页面发生的全过程，越详细越好模块为什么需要使用模块化便于代码复用和维护，代码可读性增强，避免全局污染，便于第三方库引用。 常见模块化规范有哪些 CommonJS Node.js采用的标准 一个js文件是一个模块，加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象 同步 主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。 AMD((Asynchromous Module Definition) 异步模块定义 RequireJS 在推广过程中对模块定义的规范化产出 支持对象 函数 构造器 字符串 JSON等各种类型的模块，适用define方法定义模块，允许输出模块兼容CommonJS规范。 异步 CMD（Common Module Definition）通用模块定义 SeaJS 在推广过程中对模块定义的规范化产出 与AMD类似 异步 UMD AMD和CommonJS的综合产物 原生JS模块化 ES6模块化 使用 import 关键字引入模块，通过 export 关键字导出模块，一个js文件代表一个js模块 由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。 推荐使用 CMD与AMD的区别1.对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不通过）。 2.CMD推崇依赖就近，是懒执行；AMD推崇依赖前置，是预执行。 3.AMD的api默认是一个当多个用，CMD严格的区分推崇职责单一。例如：AMD里require分全局的和局部的。CMD里面没有全局的 require,提供 seajs.use()来实现模块系统的加载启动。CMD里每个API都简单纯粹。 CommonJs如何实现模块化加载过程： 解析出一个绝对路径； 得到一个真实的加载路径（模块会被缓存）先去缓存中看一下这个文件是否存在，如果存在返回缓存 没有则创建一个模块； 得到对应文件的内容，加一个闭包，把内容塞进去，之后执行即可。 实现： Node内部提供了一个 Module构建函数。 Node.js会在js文件加载前生成一个Module实例 定义静态属性存储我们需要使用的一些值 加载模块的 load 方法，module实例传入load函数中 我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端 - 面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs从入门到放弃]]></title>
    <url>%2F2019%2F06%2F27%2Fnode-js%2F</url>
    <content type="text"><![CDATA[angular、jQuery、vue、react等是对原本JS的一种封装，而Node.js不是一个js库或框架，它是一个基于chrome v8引擎的JavaScript运行环境。 支持同步和异步，使用事件驱动。 使JavaScript 可以在浏览器之外上运行。 提供很多功能性模块（API） 开发web应用的服务端 开发客户端程序 传统js文件从服务器中拿到浏览器后，在浏览器进行解释，Node.js则是在服务端将js文件运行出结果以后，将结果返回给浏览器。 相对后台语言优势： 性能 和前台JS配合很方便 模块为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。 提高了代码的可维护性。 可以引用第三方库和内置模块，便于编写。 使用模块还可以避免函数名和变量名冲突。 使用我们可以将每个js文件都看作单独的模块，使用module.exports对外暴露，在其他模块中，可以用require()进行引用。 12345678'use strict';//hello.js作为模块function hello () &#123; console.log('hello world')&#125;module.export = hello; 123456'use strict';//在main.js中引入hello模块var hello = require('./hello');hello();//hello world CommonJS规范这种模块加载机制被称为CommonJS规范。 在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突。 一个模块想要对外暴露变量（函数也是变量），可以用module.exports = variable;，输出的变量可以是任意对象、函数、数组等等。 一个模块要引用其他模块暴露的变量，用var ref = require(&#39;module_name&#39;);就拿到了引用模块的变量，引入的对象具体是什么，取决于引入模块输出的对象。 实现原理JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。Node.js实现模块是利用了JavaScript中的闭包。 如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。 我们编写的js模块如下： 1234var s = 'Hello';var name = 'world';console.log(s + ' ' + name + '!'); 经Node.js包装后，变成： 12345678(function () &#123; // 读取的hello.js代码: var s = 'Hello'; var name = 'world'; console.log(s + ' ' + name + '!'); // hello.js代码结束&#125;)(); 这样就实现了模块的隔离。 而模块的输出则是： 123456789101112131415161718// 准备module对象:var module = &#123; id: 'hello', exports: &#123;&#125;&#125;;var load = function (module) &#123; // 读取的hello.js代码: function greet(name) &#123; console.log('Hello, ' + name + '!'); &#125; module.exports = greet; // hello.js代码结束 return module.exports;&#125;;var exported = load(module);// 保存module:save(module, exported); 变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数。 通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。 由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出。 module.exports和exportsmodule.exports和exports都可以直接输出，但exports不能赋值 首先，Node会把整个待加载的hello.js文件放入一个包装函数load中执行。在执行这个load()函数前，Node准备好了module变量： 1234var module = &#123; id: 'hello', exports: &#123;&#125;&#125;; load()函数最终返回module.exports： 12345678var load = function (exports, module) &#123; // hello.js的文件内容 ... // load函数返回: return module.exports;&#125;;var exported = load(module.exports, module); 也就是说，默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，并且初始化为空对象{}，于是，我们可以写： 12exports.foo = function () &#123; return 'foo'; &#125;;exports.bar = function () &#123; return 'bar'; &#125;; 也可以写： 12module.exports.foo = function () &#123; return 'foo'; &#125;;module.exports.bar = function () &#123; return 'bar'; &#125;; 换句话说，Node默认给你准备了一个空对象{}，这样你可以直接往里面加东西。 但是，如果我们要输出的是一个函数或数组，那么，只能给module.exports赋值： 1module.exports = function () &#123; return 'foo'; &#125;; 给exports赋值是无效的，因为赋值后，module.exports仍然是空对象{}。 如果要输出一个键值对象{}，可以利用exports这个已存在的空对象{}，并继续在上面添加新的键值； 如果要输出一个函数或数组，必须直接对module.exports对象赋值。 最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，这样，你只需要记忆一种方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端 - node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FLEX布局]]></title>
    <url>%2F2019%2F06%2F24%2Fflex%2F</url>
    <content type="text"><![CDATA[flex布局即“弹性布局”，比起我们常用的“盒模型”而言（依赖 display属性 +position属性 + float属性）,更加方便特殊布局。 任何一个容器都可以指定为Flex布局，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 Flex容器（flex container）：采用flex布局的元素 Flex项目（flex item）：容器的所有子元素自动成为容器成员，简称”项目”。 容器默认存在两根轴： 主轴（main axis）：容器内项目布局方向会沿着主轴方向排布 交叉轴（cross axis）：与主轴垂直的轴向 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器属性 flex-direction：主轴方向，即项目排列方向 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap：如果一条轴线排列不下，如何换行 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow：flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap 1flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; justify-content：项目在主轴上的对齐方式。具体对齐方式与轴的方向有关。下面假设主轴为从左到右 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items：项目在交叉轴上的对齐方式。针对一行的情况进行排列，具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content：多根轴线（多行）的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目属性 order：定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。设为跟width或height属性一样的值（比如350px），则项目将占据固定空间 flex：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 常用布局上下布局123456789101112&lt;div class="container"&gt; &lt;header class="header"&gt;HEADER&lt;/header&gt; &lt;section class="content"&gt;CONTENT&lt;/section&gt;&lt;/div&gt;&lt;style&gt; .content &#123; display: flex; flex: auto; align-items: center; justify-content: center; &#125;&lt;/style&gt; 上中下布局1234567891011121314151617181920212223&lt;div class="container"&gt; &lt;header class="header"&gt;HEADER&lt;/header&gt; &lt;section class="content"&gt; &lt;div class="left"&gt;LEFT&lt;/div&gt; &lt;div class="right"&gt;RIGHT&lt;/div&gt; &lt;/section&gt; &lt;footer class="footer"&gt;FOOTER&lt;/footer&gt;&lt;/div&gt;&lt;style&gt; .content &#123; display: flex; flex: auto; &#125; .left &#123; width: 200px &#125; .right &#123; flex: 1; &#125; .footer &#123; flex: none; &#125;&lt;/style&gt; 左上下布局123456789101112131415161718192021222324&lt;div class="container"&gt; &lt;aside class="left"&gt;LEFT&lt;/aside&gt; &lt;div class="content"&gt; &lt;header class="header"&gt;HEADER&lt;/header&gt; &lt;section class="right"&gt;CONTENT&lt;/section&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container &#123; flex-direction: row; &#125; .content &#123; display: flex; flex-flow: column wrap; flex: auto; &#125; .left &#123; width: 300px; flex: none; &#125; .right &#123; flex: auto; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE从入门到放弃の过渡]]></title>
    <url>%2F2019%2F06%2F24%2Fvue4%2F</url>
    <content type="text"><![CDATA[VUE过渡系统在DOM元素发生变化时，为其添加/删除特定类名来产生过渡效果。 transitionVUE过渡系统主要依赖transition组件来实现 transition标签将需要过渡的元素包裹起来，vue查看被包裹元素是否应用了过渡或动画，在恰当的时机添加/删除类名。 在下列情形中，可以给任何元素和组件添加进入/离开过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 类名过渡类名分为六种。 v-enter 过渡开始状态，在元素插入之前生效，元素插入以后下一帧被移除（如果使用animationend ，则是在 animationend 事件触发时删除）。 v-enter-to 过渡结束状态，在元素被插入之后下一帧生效，在过渡/动画完成之后移除 v-enter-active 整个过渡的状态，包含v-enter和v-enter-to存在的时间，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-leave 离开过渡的开始状态，在离开过渡被触发时立刻生效，下一帧被移除（如果使用animationend ，则是在 animationend 事件触发时删除）。 v-leave-to 离开过渡的结束状态。在离开过渡被触发之后下一帧生效，在过渡/动画完成之后移除。 v-leave-active 离开过渡生效时的状态。在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 如果transition没有命名，那么v-则是默认前缀，如果transition的name有自定义，如name=&#39;trans&#39;那么前缀则改为trans-。 自定义类名优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css结合使用十分有用。 enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 完成监听在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。 1234567891011121314151617181920212223242526272829303132333435&lt;div id="app"&gt; &lt;transition&gt; &lt;h1 v-if='show'&gt;title&lt;/h1&gt; &lt;/transition&gt; &lt;button @click='show = !show'&gt;click&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; show:true &#125; &#125;)&lt;/script&gt;&lt;style&gt; .v-enter-active &#123; transition: opacity 2s; transform: rotate(-7deg); animation: mymove 5s ; &#125; .v-enter &#123; opacity: 0; &#125; .v-enter-to &#123; color: green &#125; @keyframes mymove &#123; 0% &#123; background-color: red &#125; 50% &#123; background-color: black &#125; &#125;&lt;/style&gt; 默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。 有时候我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。 在这种情况下你可以用 &lt;transition&gt; 组件上的 duration 属性定制一个显性的过渡持续时间 (以毫秒计)： 毫秒计)： 1&lt;transition :duration="1000"&gt;...&lt;/transition&gt; 你也可以定制进入和移出的持续时间： 1&lt;transition :duration="&#123; enter: 500, leave: 800 &#125;"&gt;...&lt;/transition&gt; JS过滤vue可以配合js动画库使用，通过事件监听事件钩子来触发过渡。 js事件监听钩子 before-enter enter after-enter enter-cancelled before-leave leave after-leave leave-cancelled 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 可以在属性中声明 JavaScript 钩子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; &lt;!-- ... --&gt;&lt;/transition&gt;// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 上面方法中，有两个方法比较特殊，是enter()和leave()方法，它们接受了第二个参数done。当进入完毕或离开完毕后，会调用done()方法来进行接下来的操作 对于仅使用js过渡的元素添加 v-bind:css=&quot;false&quot;，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 初始渲染过渡即进入页面初始加载时的过渡效果。 transition默认初始不进行渲染 appear：表示是否开启此特性 appear-class appear-to-class appear-active-class 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;transition appear appear-active-class='appearShow'&gt; &lt;h1 v-if="show"&gt;title&lt;/h1&gt; &lt;/transition&gt; &lt;button @click="show = !show"&gt;click&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; show: true &#125; &#125;)&lt;/script&gt;&lt;style&gt; .appearShow &#123; animation: mymove 2s; &#125; @keyframes mymove &#123; 0% &#123; background-color: red &#125; 50% &#123; background-color: green &#125; &#125;&lt;/style&gt; 多元素过渡对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素： 123456&lt;transition&gt; &lt;table v-if="items.length &gt; 0"&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 可以这样使用，但是有一点需要注意： 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 &lt;transition&gt;组件中的多个元素设置 key 是一个更好的实践。 切换的元素，必须直接放在transition标签下，中间不能出现嵌套。 1234567891011121314151617181920212223242526272829303132333435 &lt;div id="app"&gt; &lt;transition&gt; &lt;ul v-if="show" key="yes" class="box"&gt; &lt;li v-for="(item, index) in items" :key="index"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul v-else key="no" class="box"&gt; &lt;li&gt;nothing&lt;/li&gt; &lt;/ul&gt; &lt;/transition&gt; &lt;button @click="show = !show"&gt;click me&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; items: [32,5,63,75,23,80], show: 'false' &#125; &#125;)&lt;/script&gt;&lt;style&gt; .box &#123; position: relative; left: 0; &#125; .v-enter &#123; left: 200px; &#125; .v-enter-active &#123; transition: left 2s ease; &#125; .v-enter-to &#123; left: 0; &#125;&lt;/style&gt; 过渡模式 in-out：新元素先进行过渡，完成之后当前元素过渡离开。 out-in：当前元素先进行过渡，完成之后新元素过渡进入。 多组件过渡不需要key，只需要动态组件。 123&lt;transition name="component-fade" mode="out-in"&gt; &lt;component v-bind:is="view"&gt;&lt;/component&gt;&lt;/transition&gt; transition-group可以同时渲染多个元素。基本用法和transition用法相同。 不同于 &lt;transition&gt;，它会以一个真实元素呈现：默认为一个 &lt;span&gt;。你也可以通过 tag特性更换为其他元素。 过度模式不可用，因为我们不再相互切换特有的元素。 内部元素 总是需要 提供唯一的 key 属性值。 新增的v-move特性 排序过滤使用v-move特性，在元素改变位置的过程中使用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。 不要使用index值作为key，因为index值会改变。 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;transition-group tag="ul"&gt; &lt;li v-for="(item, index) in items" :key="item"&gt;&#123;&#123;item&#125;&#125;--&#123;&#123;index&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt; &lt;button @click="shuffe"&gt;click&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; items: [12,456,123,4865,789,34,673] &#125;, methods: &#123; shuffe: function () &#123; this.items = _.shuffle(this.items); &#125; &#125; &#125;)&lt;/script&gt;&lt;style&gt; .v-move &#123; transition: transform 1s; &#125;&lt;/style&gt; 多维排序过滤FLIP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;style type="text/css" rel="stylesheet"&gt; button&#123; width: 100px; height: 30px; border: 1px solid #666666; border-radius: 5px; background: rgba(195, 197, 221, 0.36); margin: 10px; &#125; button:active, button:hover &#123; box-shadow: 2px 3px 2px #999 inset; border: 1.5px solid rgba(195, 197, 221, 0.57); &#125; .container &#123; display: flex; flex-wrap: wrap; /*flex容器为多行。该情况下flex子项溢出的部分会被放置到新行，子项内部会发生断行*/ width: 238px; &#125; .cell &#123; display: flex; justify-content: space-around; /*在弹性盒对象的 &lt;div&gt; 元素中的各项周围留有空白,用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式*/ align-items: center;/*居中对齐弹性盒的各项 &lt;div&gt; 元*/ width: 25px; height: 25px; border: 1px solid #aaa; margin-right: -1px; margin-bottom: -1px; &#125; .cell:nth-child(3n) &#123; margin-right: 0; &#125; .cell:nth-child(27n) &#123; margin-bottom: 0; &#125; .cells-move &#123; transition: transform 1s; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="demo"&gt; &lt;button @click="shuffle"&gt;Shuffle&lt;/button&gt; &lt;transition-group name="cells" tag="div" class="container"&gt; &lt;div v-for="cell in cells" :key="cell.id" class="cell"&gt; &#123;&#123; cell.number &#125;&#125; &lt;/div&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; new Vue(&#123; el : "#demo", data: &#123; cells: Array.apply(null, &#123;length : 81&#125;).map(function(_, index) &#123; return &#123; id: index, number : index % 9 + 1 &#125; &#125;) &#125;, methods : &#123; shuffle: function() &#123; console.log(this.cells); this.cells = _.shuffle(this.cells); &#125; &#125; &#125;) &lt;/script&gt; 当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用。 所有过渡特性都可以动态绑定，但我们不仅仅只有特性可以利用，还可以通过事件钩子获取上下文中的所有数据，因为事件钩子都是方法。这意味着，根据组件的状态不同，你的 JavaScript 过渡会有不同的表现。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE从入门到放弃の组件]]></title>
    <url>%2F2019%2F06%2F19%2Fvue3%2F</url>
    <content type="text"><![CDATA[VUE从入门到放弃の组件组件是有名字的、可复用的Vue实例，便于代码复用。 组件构造器Vue.extend()是组件构造器，相当于Vue.component()方法的第二个参数部分。 在一个vue项目中，通常会用new Vue()创建一个实例作为根组件，里面可以生成被复用的子组件，Vue.extend()创建基础Vue构造的子类。 123456789101112131415161718&lt;div id="app"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; var ex = Vue.extend(&#123; data: function () &#123; return &#123; msg: '123' &#125; &#125;, template: '&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;' &#125;) Vue.component('my-component', ex); var vm = new Vue(&#123; el: '#app', &#125;)&lt;/script&gt; 组件构造器实例化后，需要挂载到元素上，挂载可以使用$mount()方法，也可以使用component注册 123456789101112131415161718192021 &lt;div id="app"&gt; &lt;div id="div"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var ex = Vue.extend(&#123; data: function () &#123; return &#123; msg: '1234' &#125; &#125;, template: '&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;' &#125;) var vm = new Vue(&#123; el: '#app', &#125;) new ex(&#123; propsData: &#123; msg: '你好' &#125; &#125;).$mount('#div');&lt;/script&gt; 组件构造器中的data必须是个function，这样每创建一个实例，就相当于将data深拷贝一份。 注册全局注册Vue.component(&#39;name&#39;,extend)； 要在根实例初始化之前注册，命名通常用字母小写包含一个-，如my-component。 局部注册选项components:{ ‘name’:{} }，局部注册只能在当前组件中使用。 12345678910111213141516171819202122232425262728&lt;div id="app"&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;div id="part"&gt; &lt;my-parent&gt;&lt;/my-parent&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var Child = Vue.extend(&#123; data: function () &#123; return &#123; msg: '123' &#125; &#125;, template: '&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;' &#125;) var parent = Vue.extend(&#123; template: '&lt;div&gt;parent &lt;my-child&gt;&lt;/my-child&gt;&lt;/div&gt;', components: &#123; 'my-child': Child &#125; &#125;) var vm = new Vue(&#123; el: '#app', components: &#123; 'my-parent': parent &#125; &#125;)&lt;/script&gt; 在注册的时候，我们也可以不提前定义组件构造器，而直接在注册的时候定义。如Vue.component(&#39;my-component&#39;,{})。 选项大部分选项和Vue实例选项一样，除了data使用function进行返回，而不是直接赋值。 props由于组件实例作用域是独立的，无法做到组件间通信，因此子组件想要获取父组件中数据时，需要显式声明prop选项，进行数据传递。 1234567891011121314151617181920&lt;div id="app"&gt; &lt;my-parent tit="title" con="content"&gt;&lt;/my-parent&gt;&lt;/div&gt;&lt;script&gt; let child = Vue.extend(&#123; props: ['title', 'content'], template: '&lt;div&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;&lt;/div&gt;', &#125;) Vue.component('my-child', child); var vm = new Vue(&#123; el: '#app', components: &#123; 'my-parent': &#123; props: ['tit', 'con'], template: '&lt;my-child title="tit" content="con"&gt;&lt;/my-child&gt;' &#125; &#125; &#125;)&lt;/script&gt; 命名不区分大小写，如果使用时写作驼峰式命名&lt;my-child myParent=&quot;&quot;&gt;，则定义时写作props:[&#39;myparent&#39;] 如果定义时写作props:[&#39;myParent&#39;],则使用时写作my-parent。 动态传值可以将props绑定的属性的值，从父组件的data种动态获取，当data中的数据发生更改，props绑定的属性的值也会随之变化。 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;my-parent title="title" content="content"&gt;&lt;/my-parent&gt;&lt;/div&gt;&lt;script&gt; let child = Vue.extend(&#123; props: ['title', 'content'], template: '&lt;div&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;&lt;/div&gt;', &#125;) Vue.component('my-child', child); var vm = new Vue(&#123; el: '#app', components: &#123; 'my-parent': &#123; data: function () &#123; return &#123; val: &#123; tit: '123', con: '12345678978978978' &#125; &#125; &#125;, template: '&lt;my-child :title="val.tit" :content="val.con"&gt;&lt;/my-child&gt;' &#125; &#125; &#125;)&lt;/script&gt; 绑定类型默认都是单向绑定，也就是说，父组件数据更改会使得子组件更新，但子组件数据修改，父组件并不会随之改变。 vue2.0禁止在子组件内部修改props，否则控制台会发出警告。 如果希望将props值作为本地数据使用，可以在data返回值中新定义一个变量，将props值赋给新变量，单独使用。 如果props值是个原始数据，需要处理后再显示，则使用计算属性处理。 props验证参照选项中props验证属性及用法。 非props特性$attrs实际上，非props特性就是指没有在props中定义，但是在标签上使用了的属性。 比如props上只定义了一个value属性，但是自定义组件在使用的时候，在其中多传入了一个title属性，如&lt;my-component value=&#39;123&#39; title=&#39;456&#39;&gt;&lt;/my-component&gt;。此时多余的title属性并不会被删除，这个多余的属性会被添加到当前组件的根元素上。 如果不希望多余的属性被当前组件的跟元素继承，可以在选项中设置inheritAttrs:false。 注意，inheritAttrs: false 选项不会影响 style 和 class 的绑定 非props属性可以使用实例方法this.$attrs来获取。结合inheritAttrs: false和$attrs 可以手动决定这些特性会被赋予哪个元素。 1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;my-component msg="massage" type="checkbox" label="inputBox"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', components: &#123; 'my-component': &#123; inheritAttrs: false, props: ['msg'], template: `&lt;div&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;input :type="$attrs.type"&gt; &lt;span&gt;&#123;&#123;$attrs.label&#125;&#125;&lt;/span&gt; &lt;/div&gt;`, mounted: function () &#123; console.log(this.$attrs); &#125; &#125; &#125; &#125;)&lt;/script&gt; 如果同时存在外部传入的值和组件本身的设置好的值，对于绝大多数特性来说，外部传入的值会替换掉组件内部设置好的值。但，class 和 style 特性会将两边的值合并起来。 组件间通信直接通信vue提供了三个实例方法可以直接进行通信。 基本上不用这种方法修改实例数据，只做数据获取。 $root：组件所在根实例，如果当前实例没有父实例，此实例将会是其自己 $parent：组件所在父组件实例 $children：组件包含的所有子组件实例，需要注意 $children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。 $refs：访问特定的子组件实例。先给子组件实例标签上定义一个ref标识，就可以在父组件用this.$refs访问。当 ref 和 v-for 一起使用的时候，你得到的引用将会是一个包含了对应数据源的这些子组件的数组。它只会在组件渲染完成之后生效，并且不是响应式的。避免在模板或计算属性中访问 $refs。 Props（最常用）介绍见上。 自定义事件不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。因此，推荐你始终使用 kebab-case 的事件名。 用$emit和v-on监听事件触发，便于父子组件之间通信。 比如我们在子组件里点击某个按钮时，需要父组件上某个数据进行更新时。我们可以在子组件上用v-on:click=&quot;$emit(&#39;eventName&#39;)&quot;来监听子组件的点击事件，子组件被点击以后，$emit就会派发名叫eventName的事件。然后在父组件上定义v-on:eventName=&quot;function&quot;，用v-on来监听eventName的触发，接收到子组件的触发信号以后，执行function。 $emit的第二个参数可以是一个params，父组件可以在监听时，用$event获取当前params，如果父组件事件处理函数是一个方法，则将这个params作为第一个参数传入方法中。 通过 $on(eventName, eventHandler) 侦听一个事件 通过 $once(eventName, eventHandler) 一次性侦听一个事件 通过 $off(eventName, eventHandler) 停止侦听一个事件 这种方式，类似于angular.js中用广播在兄弟间通信。 常用于组件封装。 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;my-child @change-parent='parent' :title="title"&gt;&lt;/my-child&gt;&lt;/div&gt;&lt;template id="temp"&gt; &lt;div&gt; &lt;h1 @click='childClick'&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 子组件获取父组件的传值作为title。 // 点击时，向父组件派发change-parent事件，父组件监听到事件以后进行数据更改。 Vue.component('my-child', &#123; props: ['title'], data: function () &#123; return &#123; content: 'my content' &#125; &#125;, template: '#temp', methods: &#123; childClick: function () &#123; this.$emit('change-parent') &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; title: 'my title' &#125;, methods: &#123; parent: function () &#123; this.title += '123'; &#125; &#125; &#125;)&lt;/script&gt; model选项一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的event，但是像单选框、复选框等输入控件的 value 特性是以change作为event标识的。model 选项可以用来避免这样的冲突。 1&lt;my-checkbox v-model="foo" value="some value"&gt;&lt;/my-checkbox&gt; 上述代码相当于： 12345&lt;my-checkbox :checked="foo" @change="val =&gt; &#123; foo = val &#125;" value="some value"&gt;&lt;/my-checkbox&gt; model属性让我们在组件内部就可以调用到其父级的事件。 v-model实际上原理就是在子组件中加入一个model对象，里面包含了两个选项，model:{prop:&quot;自定义&quot;,event:&quot;自定义&quot;}来监听子组件变化。默认input输入框的prop是value、event是input。 prop：父组件最开始将参数传到子组件时，先将参数赋给prop对应的、自定义命名的值，然后再由prop的值传给props中同名参数，子组件的template再从props中的同名参数里取值。 传值过程：父组件 -&gt; model中的prop（命名自定义） -&gt; props中的参数（与前一项命名一致） -&gt; template中绑定的数据 event：相当于父组件需要监听的事件的名称，一个标识。子组件$emit派发一个自定义事件，event接收到当前触发的事件名称，确认是父组件正在监听的事件，就将变化的值默认传给prop中的值，以修改父组件中数据。由于v-model本身只是数据的双向绑定，不存在额外的事件触发，因此event中只需要一个自定义事件名称即可，不涉及调用其他方法。 123456789101112131415161718192021222324252627282930313233343536373839&lt;div id="app"&gt; &lt;my-checkbox v-model="ischecked"&gt;&lt;/my-checkbox&gt;&lt;/div&gt;&lt;template id="temp"&gt; &lt;input type="checkbox" :checked="checked" @change="changeChild($event.target.checked)"&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-checkbox', &#123; template: '#temp', props: &#123; checked: Boolean &#125;, model: &#123; prop: 'checked', event: 'changeInput' &#125;, methods: &#123; changeChild: function (val) &#123; this.$emit('changeInput', val); &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; ischecked: true &#125;, mounted: function () &#123; console.log(this.ischecked); &#125;, beforeUpdate: function () &#123; console.log(this.ischecked); &#125;, updated: function () &#123; console.log(this.ischecked); &#125; &#125;)&lt;/script&gt; 将原生事件绑定到组件想要在一个组件的根元素上直接监听一个原生事件可以使用 v-on 的 .native 修饰符。 1&lt;base-input v-on:focus.native="onFocus"&gt;&lt;/base-input&gt; 不过在你尝试监听一个类似 &lt;input&gt; 的非常特定的元素时，这并不是个好主意。比如上述 &lt;base-input&gt; 组件可能做了如下重构，所以根元素实际上是一个 &lt;label&gt;元素： 12345678&lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind="$attrs" v-bind:value="value" v-on:input="$emit('input', $event.target.value)" &gt;&lt;/label&gt; 这时，父级的 .native 监听器将静默失败。它不会产生任何报错，但是 onFocus 处理函数不会如你预期地被调用。 这时可以使用 $listeners 属性，配合 v-on=&quot;$listeners&quot; 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 &lt;input&gt; 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;div id="app"&gt; &lt;base-input v-model="username" label="基础输入组件" @click.native="handleBaseInputClick" v-on:focus="handleBaseInputFocus" placeholder="请输入您的名字" class="username-input"/&gt;&lt;/div&gt;&lt;template id="temp"&gt; &lt;label id="base-label"&gt; &#123;&#123;label&#125;&#125; &lt;input :value="value" v-bind="$attrs" v-on="inputListeners"/&gt; &lt;/label&gt;&lt;/template&gt;&lt;script&gt; // 注册组件 // 因为base-input的外层是一个label元素，所以默认情况下使用v-on:focus是无效的，所以需要配合 // $listeners使用，该属性可以把事件的监听指向组件中某个特定的元素 // 注意：如果父级的事件添加了.native修饰符，在$listeners中不会体现出来的 Vue.component('base-input',&#123; inheritAttrs: false, props: ['label','value'], template: '#temp', computed: &#123; inputListeners () &#123; var vm = this return Object.assign(&#123;&#125;, this.$listeners, &#123; input: function () &#123; vm.$emit('input', event.target.value) &#125;, focus: function (event) &#123; vm.$emit('focus', 'onfocus了') &#125; &#125; ) &#125; &#125;, mounted: function()&#123; console.log(`$attrs:`) console.log(this.$attrs) console.log(`$listeners:`) console.log(this.$listeners) // 父级添加的所有属性都在这里 &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; username: '' &#125;, beforeUpdate: function () &#123; console.log(this.username) &#125;, methods: &#123; handleBaseInputFocus: function(ev)&#123; console.log(ev) &#125;, handleBaseInputClick: function(ev)&#123; console.log(ev.type) &#125; &#125; &#125;)&lt;/script&gt; $listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器，并且没有通过this.$emit返回的，子组件获取到$listeners以后可以用v-on进行调用。 相当于可以在子组件中使用父组件事件。 .sync修饰符.sync 其实是一个缩写 @update:isShow=”val=&gt;isShow=val”语法糖。 作为一个编译时的语法糖存在，会被扩展为一个自动更新父组件属性的 v-on 监听器。说白了就是让我们手动进行更新父组件中的值了，从而使数据改动来源更加的明显。 1234567891011121314151617181920212223242526272829303132&lt;div id="app"&gt; &lt;my-sync :name.sync='userName'&gt;&lt;/my-sync&gt; &#123;&#123;userName&#125;&#125;&lt;/div&gt;&lt;template id="temp"&gt; &lt;div&gt; &lt;label&gt;input&lt;/label&gt; &lt;input v-model="text"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-sync', &#123; props: ['name'], template: '#temp', data: function () &#123; return &#123; text: '' &#125; &#125;, watch: &#123; text: function (newVal) &#123; this.$emit('update:name', newVal) &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; userName: '' &#125; &#125;)&lt;/script&gt; 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。 用： 1&lt;text-document v-bind.sync="doc"&gt;&lt;/text-document&gt; 这样会把 doc 对象中的每一个属性 (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。 将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。 依赖注入provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。 让后代可以访问到父级，允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 非响应式。 provide 选项由父级使用，应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys的环境下可工作。 inject 选项由子级使用，应该是： 一个字符串数组，或 一个对象，对象的 key 是本地的绑定名，value 是： 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或 一个对象，该对象的： from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol) default 属性是降级情况下使用的 value 内容分发我们在使用子组件的时候，很有可能子组件只提供基础交互，展示的内容及事件都是由父组件传递过去的。 对此vue提供了一种混合父组件内容和子组件模板的方式，这种方式称为内容分发，使用&lt;slot&gt;元素为原始内容的插槽，作为承载分发内容的出口。 基础用法组件的template定义时，在其中放入&lt;slot&gt;标签，使用组件模板被渲染的时候，在其中添加的多余的代码都会被识别并且原样放进去。 但如果组件模板种没有包含一个 &lt;slot&gt; 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;my-slot title="title"&gt; &lt;div&gt;content 123456789&lt;/div&gt; &lt;h2&gt;h2 title&lt;/h2&gt; &lt;/my-slot&gt;&lt;/div&gt;&lt;template id="temp"&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-slot', &#123; props:['title'], template:'#temp' &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; title: 'h1 title' &#125; &#125;)&lt;/script&gt; 作用域当我们想在&lt;slot&gt;中使用变量的时候，我们会纠结到底变量是存在在组件定义的作用域里，还是调用组件时的父作用域。我们需要记住一个点：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 所以，slot中的变量，都应该在父级模板中有定义。 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;my-slot title="title"&gt; &lt;div&gt;content 123456789&lt;/div&gt; &lt;h2&gt;h2 title&lt;/h2&gt; &lt;input type="text" v-model='text'&gt; &#123;&#123;text&#125;&#125; &lt;/my-slot&gt;&lt;/div&gt;&lt;template id="temp"&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-slot', &#123; props:['title'], template:'#temp' &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; title: 'h1 title', text: '' &#125; &#125;)&lt;/script&gt; 预设内容官方称之为‘后备内容’，我觉得更适合称为‘预设’。在没有可以渲染的内容时，slot渲染提前预设好的内容。就像我们封装的button组件，通常预设值就是default。 123456789101112131415161718192021&lt;div id="app"&gt; &lt;my-slot title="title"&gt;&lt;/my-slot&gt;&lt;/div&gt;&lt;template id="temp"&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;slot&gt;submit&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-slot', &#123; props: ['title'], template: '#temp' &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; title: '123h1' &#125; &#125;)&lt;/script&gt; 具名插槽给slot定义具体的名称，可以用v-slot做特定的识别。 在我们不给slot定义具体名称的时候，默认将插入模板放在默认插槽里v-slot:default=&quot;&quot;。 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;my-slot&gt; &lt;template v-slot:header&gt; &lt;h1&gt;head&lt;/h1&gt; &lt;/template&gt; &lt;template v-slot:main&gt; &lt;h1&gt;main&lt;/h1&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;h1&gt;foot&lt;/h1&gt; &lt;/template&gt; &lt;/my-slot&gt;&lt;/div&gt;&lt;template id="temp"&gt; &lt;div&gt; &lt;header&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot name="main"&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-slot', &#123; template: '#temp' &#125;) var vm = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 注意 v-slot 只能添加在一个 &lt;template&gt; 上 ，除非当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 v-slot 直接用在组件上。 支持动态插槽名，v-slot:[动态插槽名] 支持缩写，v-slot可以用#代替，v-slot:head缩写为#head 作用域插槽让在父级作用域里渲染的插槽内容，可以访问子组件数据。 将变量作为属性绑定在子组件template的&lt;slot&gt;标签上，称为插槽 prop。 然后在父级作用域中，使用子组件，在其上给 v-slot 定义一个我们提供的插槽 prop 的名字，如‘name’。 使用时，从我们定义好的特性里取值，如‘name.data’。 12345678910111213141516171819202122232425262728293031323334353637&lt;div id="app"&gt; &lt;my-slot&gt; &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;template v-slot:default="tit"&gt; &lt;h2&gt;&#123;&#123;tit.tit&#125;&#125;&lt;/h2&gt; &lt;/template&gt; &lt;/my-slot&gt; &lt;!-- 直接加在组件上也可以 &lt;my-slot v-slot:default="tit"&gt; &#123;&#123;tit.tit&#125;&#125; &lt;/my-slot&gt; --&gt;&lt;/div&gt;&lt;template id="temp"&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;slot v-bind:tit="childtitle"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-slot', &#123; template:'#temp', data: function () &#123; return &#123; childtitle: "I'm child title", title:'123' &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; title: "I'm parent title" &#125; &#125;)&lt;/script&gt; 作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个参数的函数里. 这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式，可以用ES2015解构赋值来传入具体插槽prop。 1234567891011121314151617181920212223242526272829&lt;div id="app"&gt; &lt;my-slot v-slot:default='&#123; title &#125;'&gt; &lt;h3&gt;&#123;&#123;title.value&#125;&#125;&lt;/h3&gt; &lt;p&gt;&#123;&#123;title.text&#125;&#125;&lt;/p&gt; &lt;/my-slot&gt;&lt;/div&gt;&lt;template id="temp"&gt; &lt;div&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;slot v-bind:title="title"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-slot', &#123; template: '#temp', data: function () &#123; return &#123; title: &#123; value: '456', text: 'child' &#125; &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 动态组件多个组件使用同一挂载点，根据条件进行切换，常用在路由和tab页签切换中。 基本用法通过 Vue 的 &lt;component&gt; 元素加一个特殊的 is 特性来实现 12&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;&lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt; 在上述示例中，currentTabComponent 可以包括 已注册组件的名字，或 一个组件的选项对象 12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;ul&gt; &lt;li @click="currentTab = 'home'"&gt;Home&lt;/li&gt; &lt;li @click="currentTab = 'tab1'"&gt;Tab1&lt;/li&gt; &lt;li @click="currentTab = 'tab2'"&gt;Tab2&lt;/li&gt; &lt;li @click="currentTab = 'my-component'"&gt;my-component&lt;/li&gt; &lt;/ul&gt; &lt;component v-bind:is="currentTab"&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-component', &#123; template: `&lt;div&gt;I'm component&lt;/div&gt;` &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; currentTab: 'home' &#125;, components: &#123; home: &#123; template: `&lt;div&gt;I'm Home&lt;/div&gt;` &#125;, tab1: &#123; template: `&lt;div&gt;I'm Tab1&lt;/div&gt;` &#125;, tab2: &#123; template: `&lt;div&gt;I'm Tab2&lt;/div&gt;` &#125; &#125; &#125;)&lt;/script&gt; 使用keep-alive保持了它的状态，切换时不会注销事件监听等。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id="app"&gt; &lt;ul&gt; &lt;li @click="currentTab = 'home'"&gt;Home&lt;/li&gt; &lt;li @click="currentTab = 'tab1'"&gt;Tab1&lt;/li&gt; &lt;li @click="currentTab = 'tab2'"&gt;Tab2&lt;/li&gt; &lt;li @click="currentTab = 'my-component'"&gt;my-component&lt;/li&gt; &lt;/ul&gt; &lt;keep-alive&gt; &lt;component v-bind:is="currentTab"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt;&lt;template id="temp"&gt; &lt;div&gt; &lt;p&gt;Component&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; Vue.component('my-component', &#123; template: '#temp', created: function () &#123; console.log('create'); &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; currentTab: 'home' &#125;, components: &#123; home: &#123; template: `&lt;div&gt;I'm Home&lt;/div&gt;` &#125;, tab1: &#123; template: `&lt;div&gt;I'm Tab1&lt;/div&gt;` &#125;, tab2: &#123; template: `&lt;div&gt;I'm Tab2&lt;/div&gt;` &#125; &#125; &#125;)&lt;/script&gt; 异步组件在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 组件间循环引用AB两个组件互相引用时，由于我们会使用webpack打包工具，此时模块系统发现A需要B，B又需要A，找不到介入点，就会报错。 因此，我们需要给模块系统一个点，在那里“A 反正是需要 B 的，但是我们不需要先解析 B。” 等到生命周期钩子 beforeCreate 时去注册悖论的子组件。 123beforeCreate: function () &#123; this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default&#125; 或者，在本地注册组件的时候，可以使用 webpack 的异步 import： 123components: &#123; TreeFolderContents: () =&gt; import('./tree-folder-contents.vue')&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>组件 - vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE从入门到放弃の指令]]></title>
    <url>%2F2019%2F06%2F19%2Fvue2%2F</url>
    <content type="text"><![CDATA[VUE从入门到放弃の指令内置指令自定义指令操作DOM，提高代码复用率。vue2.0中，代码复用和抽象的主要形式是组件，但有时候也需要自定义指令，比如。 在图片未完成加载前，用随机的背景色占位，图片加载完成后才直接渲染出来 自定义指令的第二用处是用于集成第三方插件。 注册全局注册Vue.directive(&#39;name&#39;,object)name是指令的唯一标识，如v-name，object是指令的相关属性和钩子函数。 局部注册directive：{&#39;name&#39;:object}在组件的选项中注册，只能在该组件内使用。 name可以采用驼峰式命名如nameExp，使用时则用 - 连接v-name-exp。 钩子函数都是可选。 bind：指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 参数除el外，都是只读的。按顺序传参。 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;div id="app"&gt; &lt;p v-have-name&gt;111&lt;/p&gt; &lt;h1 v-inline-order="123+1"&gt;&lt;/h1&gt; &lt;button @click="clickBtn"&gt;click&lt;/button&gt; &lt;button @click="unbindBtn"&gt;unbind&lt;/button&gt; &lt;h1 v-inline-order2:foo="[msg]" id='bind' v-if="ifbind"&gt;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; Vue.directive('haveName',&#123; bind: function (el) &#123; console.log(el); &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; msg:'456', ifbind: true &#125;, methods: &#123; clickBtn: function () &#123; this.msg += "123" &#125;, unbindBtn: function () &#123; //v-if触发解绑事件 this.ifbind = false; &#125; &#125;, directives: &#123; 'inlineOrder': &#123; inserted: function (el, binding) &#123; console.log(el, binding) &#125; &#125;, 'inlineOrder2': &#123; bind: function (el) &#123; this.msg = "789" &#125;, inserted: function (binding) &#123; //此处显示的是当前的el。 //因为默认el是第一个参数,哪怕起名叫binding,实际上还是显示el的值。 console.log(binding) &#125;, update: function (el, binding, oldVnode) &#123; console.log(el, binding, oldVnode) &#125;, componentUpdated: function (el, binding, Vnode) &#123; console.log(el, binding, Vnode) &#125;, unbind: function () &#123; console.log('unbind') &#125; &#125; &#125; &#125;);&lt;/script&gt; 注意事项 自定义指令上参数值如果是一个实例上的变量，则用[]包裹。 指令函数能够接受所有合法的 JavaScript 表达式。 如果想在 bind 和 update 时触发相同行为，而不关心其它的钩子，可以采用简写。直接在Vue.directive(&#39;name&#39;,object)或directive:{‘name’:object}时，将object写成需要执行的函数即可。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE从入门到放弃の简介与基础特性]]></title>
    <url>%2F2019%2F06%2F16%2Fvue1%2F</url>
    <content type="text"><![CDATA[VUE从入门到放弃の简介与基础特性Vue小白入门手册，所有涉及到的代码块，均在压缩包里有存档。 简介模式：MVVM（Module-View Module-View） 特点： 轻量级 响应式：数据绑定，保持数据和视图的一致 组件式：可以将任意封装好的代码注册成标签调用 模块化 适用范围： 前后端分离项目 IE8+、Andiroid 4.2+、IOS 7+ 运行流程： Vue使用HTML的Parser将HTML模板通过编译生成AST（Abstract Syntax Tree），再由AST生成Vue的render函数（渲染函数），渲染函数结合数据生成Virtual DOM树（虚拟DOM树），Diff和Patch后生成新的UI。 基础特性实例Vue的使用，都是通过构造函数Vue({option})创建一个Vue的根实例来启动，在实例化的同时可以往里传入一个由众多选项组成的对象： 1var vm = new Vue(&#123;&#125;); Vue构造器可用Vue.extend()方法扩展，Vue.js组件都是被扩展的Vue实例。 选项DOMVue实例中最主要影响模板或DOM的选项为el和template。 el：string|HTMLElement只在由new创建的实例中遵守。 为实例提供挂载点，一般使用css选择符，或原生DOM元素，实例挂载之后可以用vm.$el访问。 不推荐挂载root实例到&lt;html&gt;或&lt;body&gt;上 1234567891011121314&lt;div id="app"&gt; &#123;&#123;init&#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', methods: &#123; init: function () &#123; return vm.$el; &#125; &#125; &#125;); console.log(vm.$el);&lt;/script&gt; 控制台打印出#appnode的信息，屏幕显示#app的内部信息（据测试，init中return vm.$el和return vm.el效果相同）。 template：string为挂载元素提供字符串模板，模板将会替换挂载元素，挂载元素内容将被忽略，除非模板的内容有分发slot。 1234567&lt;div id="app"&gt;I'm app&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', template: "&lt;p&gt;I'm template&lt;/p&gt;" &#125;);&lt;/script&gt; 页面显示I’m template，I’m app字样被直接替换。 使用时，我们通常不会将所有的HTML字符串直接写在js里面，经常用&#39;#tpl&#39;的方式赋值。 用&lt;template&gt;标签包含模板，template选项指定替换的模板Id； 12345678910111213&lt;div id="app"&gt;I'm app&lt;/div&gt;&lt;template id="tpl"&gt; &lt;p&gt;I'm template&lt;/p&gt;&lt;/template&gt;&lt;template id="tpl2"&gt; &lt;p&gt;I'm template2&lt;/p&gt;&lt;/template&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', template: '#tpl2' &#125;);&lt;/script&gt; 页面显示I’m template2，I’m app字样被直接替换。 或&lt;script type=&quot;x-template&quot;&gt;包含模板。 12345678910&lt;div id="app"&gt;I'm app&lt;/div&gt;&lt;script type="x-template" id="tpl"&gt; &lt;p&gt;I'm template&lt;/p&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', template: '#tpl' &#125;);&lt;/script&gt; 页面显示I’m template，I’m app字样被直接替换。 render：function字符串模板代替方案，优先级高于template选项，类似于原生中document.createElement();，动态生成template模板。 接收createElement方法作为第一个参数，创建VNode后返回。 1234567891011121314151617181920212223242526&lt;div id="app"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', render: function (creatElement) &#123; return creatElement( //第一个参数为要创建的盒子名称，可以是一个HTML标签，也可以是一个组件或函数 'div', //第二个参数为数据对象 &#123; 'style': &#123; color: 'red' &#125;, attrs: &#123; id: 'app1' &#125; &#125;, [ creatElement('h1','h1'), creatElement('h2','h2'), 'div' ] ) &#125; &#125;);&lt;/script&gt; createElement接收三个参数： 第一个参数为要创建的盒子名称，可以是一个HTML标签，也可以是一个组件或函数； 第二个参数为数据对象Object（可选），定义当前创建的盒子的属性、事件等数据，选项较多； 第三个参数为子节点Attr（可选），当前盒子下存在的子节点集合，可以createElement嵌套。 如果组件为函数组件，会额外接收第二个参数context，为没有实例的函数组件提供上下文信息。 1234567891011121314151617181920212223242526272829 &lt;div id="app"&gt; &lt;div&gt; 111 &lt;my-conponent value="1"&gt;222&lt;/my-conponent&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-conponent',&#123; functional: true, render: function(h, context) &#123; return h( 'li', &#123; on: &#123; click: function() &#123; console.log(context); console.log(context.parent); console.log(context.props) &#125; &#125; &#125;, context.children ) &#125; &#125;) var vm = new Vue(&#123; el: '#app' &#125;);&lt;/script&gt; renderError：function只在开发者环境下有效。 当 render 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 renderError。这个功能配合 hot-reload 非常实用。 123456789101112&lt;div id="app"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', render: function (h) &#123; throw new Error('错误测试') &#125;, renderError: function (h, err) &#123; return h('pre', &#123; style: &#123; color: 'blue' &#125;&#125;, err.stack) &#125; &#125;)&lt;/script&gt; throw new Error()前端异常捕获。 数据data：object | function组件定义时只接受function。 Vue实例通过data选项定义数据，这些数据可以在对应模板中绑定并使用。不推荐观察拥有状态行为的对象。 如果data中传入一个对象，则Vue实例代理对象中的属性，而不会深拷贝。此句意思是，如果对象在外层定义，然后传入data中，如果外层对象被修改，则data也随之改变。这种称为响应式数据。只有在初始化时传入的对象才是响应式的，声明完实例之后，如果要加入响应式变量，需要调用实例方法$set，但官方并不推荐。 vm.$data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 vm.a 等价于访问 vm.$data.a 123456789101112131415&lt;div id="app"&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; title: "I'm title" &#125; &#125;); console.log(vm.$data.title); console.log(vm.title); console.log(vm.$data); console.log(vm.$data._property);&lt;/script&gt; 页面显示I’m title，控制台显示I’m title，I’m title，对象，undefined。 props：array | object用于接收来自父组件的数据。 使用object作为参数时，可以使用选项： type：类型。String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数、或上述内容组成的数组。 default：默认值。any。如果该props值没被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。 required：必填项。Boolean。 validator：自定义验证函数。function。会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值，控制台会被抛出警告。 组件定义props时，属性如果用驼峰命名，在使用时，则使用-进行连接，参照下例中myMessage。 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;props-simple size="123" my-message="message"&gt;&lt;/props-simple&gt; &lt;props-advanced height='1' age='2'&gt;&lt;/props-advanced&gt;&lt;/div&gt;&lt;script&gt; Vue.component('props-simple', &#123; props: ['size', 'myMessage'], template: '&lt;h3&gt;&#123;&#123; myMessage &#125;&#125;:&#123;&#123;size&#125;&#125;&lt;/h3&gt;' &#125;) Vue.component('props-advanced', &#123; props: &#123; height: String, age: &#123; type: String, default: 0, required: true, validator: function (val) &#123; return val &gt;= 0 &#125; &#125; &#125;, template: '&lt;div&gt;&lt;input v-bind:value="age"&gt;&lt;/div&gt;' &#125;) var vm = new Vue(&#123; el: '#app' &#125;);&lt;/script&gt; propsData：{ [key: string]: any }创建实例时传递 props，只用于 new 创建的实例中。通常用于方便测试。 1234567891011121314151617&lt;div id="app"&gt; &lt;h1 id="msg"&gt;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app' &#125;) var Comp = Vue.extend(&#123; props: ['msg'], template: '&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;' &#125;) new Comp(&#123; propsData: &#123; msg: 'hello' &#125; &#125;).$mount("#msg")&lt;/script&gt; 方法methods：{ [key: string]: function }methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例 不能用箭头函数定义，否则会使this指向父级作用域的上下文。 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;button @click="changeMsg"&gt;click&lt;/button&gt; &lt;button @click="changeMsgThis"&gt;click this&lt;/button&gt; &lt;button @click="changeMsgVm"&gt;click vm&lt;/button&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: "I'm msg" &#125;, methods: &#123; changeMsg: function () &#123; this.msg = this.msg + '123'; &#125;, changeMsgThis: () =&gt; &#123; console.log(this); this.msg = this.msg + '123'; &#125;, changeMsgVm: () =&gt; &#123; console.log(vm); vm.msg = vm.msg + '123'; &#125; &#125; &#125;)&lt;/script&gt; changeMsg点击后正常显示msg+‘123’，changeMsgThis点击后控制台显示this指向window，changeMsgVm点击后和changeMsg点击效果相同。 生命周期Vue实例在创建时需经过一系列初始化步骤，钩子函数就是在这个过程中对外公开的、可以进行业务逻辑操作的函数，可以准确定位Vue实例状态。 所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。 beforeCreate：function实例创建之前调用。 created：function实例创建后调用 beforeMount：function挂载之前调用。 mounted：function实例挂载之后调用。 beforeUpdate：function数据更新前调用，访问现有DOM。 updated：function数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 尽量避免在此期间更改状态，最好用计算属性或watch代替。 activated：functionkeep-alive 组件激活时调用。 deactivated：functionkeep-alive 组件停用时调用。 beforeDestroy：function实例销毁之前调用。 destroyed：function实例销毁后调用。 errorCaptured：function捕获一个来自子孙组件的错误时被调用 数据绑定Vue的核心是一个响应式的数据绑定系统。 普通用法文本插值双花括号{ {name} }，修改name值，DOM数据随之改变。 HTML属性v-bind绑定属性名。 表达式双花括号{ { } }中可以识别简单的、单个js表达式。不支持正则。 过滤器以管道符 | 在表达式后面添加过滤器。允许过滤器链式使用，也允许多个参数 VUE2.0以后不存在内置过滤器，可以自定义过滤器。 计算属性将原始数据渲染处理以后返回显示到视图上，并不修改原始数据。 getter（默认属性）获取处理过的数据方法。 setter自定义设置数据的方法。 表单v-model进行表单数据的双向绑定，会根据控件类型自动选取正确的方法来更新元素。 v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。应该通过 JavaScript 在组件的 data 选项中声明初始值。 text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 修饰符.lazy：默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步。添加 lazy 修饰符，则变为用 change 事件进行同步。 .number： 自动将用户的输入值转为数值类型。 .trim：自动过滤用户输入的首尾空白字符。 Class与Style绑定Class绑定v-bind:class=&quot;&quot;对象或数组，可以是个data里定义的变量，也可以是直接赋值的一个object。 1234567891011121314151617&lt;div id="app"&gt; &lt;div v-bind:class="classList"&gt;&lt;/div&gt; &lt;div v-bind:class="&#123;'active':active&#125;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; classList: &#123; active: true, classA: true, classB: false &#125;, active: true &#125; &#125;)&lt;/script&gt; Style绑定v-bind:style=&quot;&quot;对象或数组，数组是将多个对象应用在同一个元素上。:style会自动添加厂商前缀（-webket-之类） 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;div v-bind:style="styleList"&gt;blue&lt;/div&gt; &lt;div v-bind:style="&#123;color:'red'&#125;"&gt;red&lt;/div&gt; &lt;div v-bind:style="[color,font]"&gt;green&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; styleList: &#123; color: 'blue', fontSize: '20px' &#125;, color: &#123; color: 'green' &#125;, font: &#123; fontSize: '30px' &#125; &#125; &#125;)&lt;/script&gt; 模板渲染获取数据以后，将其加载到写好的模板中，此过程称为渲染。早期web项目在服务端渲染，然后直接插入HTML模板中国（JSP），现在大多使用前端渲染。vue.js在浏览器也就是前端渲染，vue2.0开始支持服务端渲染。 前端渲染优势： 业务分离。 计算量转移，减轻服务器压力。 后端渲染优势： 对搜索引擎更友好。 首页加载时间短，无需获取数据后再进行JS渲染。 条件渲染 v-if/v-else/v-showv-if这块内容只会在指令的表达式返回 Truthy 值的时候被渲染。 切换时会引起DOM变化，有一个局部的编译/卸载过程，由于其惰性加载，因此初始为假时不做操作，有较高的切换消耗。 Falsy值包括：false、undefined、null、正负0、NaN、””，其余都是Truthy 值，Infinity、空数组、”0″都是Truthy值。 v-else必须紧跟v-if，不然不起作用。 v-show用法和v-if一样，但只切换元素display属性。 切换时会引起样式变化，初始为假时照常操作，有较高的初始渲染消耗。 12345678910&lt;div id="app"&gt; &lt;h1 v-if="1"&gt;if&lt;/h1&gt; &lt;h1 v-else&gt;else&lt;/h1&gt; &lt;h1 v-show="[]"&gt;show&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 列表渲染 v-for将数据循环渲染进模板中，需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素，items可以是数字。还可以添加第二个参数index为当前元素的索引。 需要为每项提供一个唯一 的、string或number类型的key 属性。 默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。 1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;div v-for="(item, index) in items" :key="index"&gt; &lt;h1&gt;&#123;&#123;item.name&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; items: [ &#123; name: 'baiyu' &#125;, &#123; name: 'xiaobai' &#125;, &#123; name: 'xiaoyuzhou' &#125; ] &#125; &#125;)&lt;/script&gt; 不推荐在同一元素上使用v-for和v-if，因为v-for优先级更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。 template将多个元素包裹成一个模块，方便做整体渲染。 事件绑定与监听v-onv-on可以绑定methods中的方法作为事件处理器，v-on:后跟原生事件名称，可以依次绑定多个事件，按顺序执行。如v-on:click=“method” v-on:click=&quot;method2&quot;。缩写：@click=“method”。 v-on也支持内联一句的js代码。 用event和$event获取DOM事件对象。 12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;button v-on:click="change"&gt;click&lt;/button&gt; &lt;button v-on:click="change1"&gt;click1&lt;/button&gt; &lt;button v-on:click="change2($event)"&gt;click2&lt;/button&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;msg1&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123;msg2&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'msg', msg1: '', msg2: '' &#125;, methods: &#123; change: function () &#123; this.msg += '123' &#125;, change1: function (event) &#123; console.log(event); this.msg1 = event.type; &#125;, change2: function (event) &#123; console.log(event); this.msg2 = event.type; &#125; &#125; &#125;)&lt;/script&gt; 修饰符事件修饰符处理DOM事件细节，比如event.preventDefault() 或 event.stopPropagation()。修饰符可以串联。 .stop 阻止单击冒泡 .prevent 防止执行预设的行为 .capture 使用capture模式添加事件监听，与事件冒泡的方向相反，事件捕获由外到内所有 .self 只当在 event.target 是当前元素自身时触发处理函数，只会触发自己范围内的事件，不包含子元素 .once 事件只触发一次就失效 .passive 滚动事件会立即触发，不必等待onScroll完成 按键修饰符为常见按键码命名，便于使用。 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 附录createElement数据对象选项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; //和v-bind:class一样的API 'class': &#123; foo: true, bar: false &#125;, //和v-bind:style一样的API 'style': &#123; color: 'red', fontSize: '14px' &#125;, //正常的HTML特性 attrs &#123; id: 'foo' &#125;, //组件props props: &#123; myProp: 'bar' &#125;, //DOM属性 domProps: &#123; innerHTML: 'baz' &#125;, //自定义事件监听器"on" //不支持如v-on:keyup.enter的修饰器 //需要手动匹配keyCode on: &#123; click: this.clickHandler &#125;, //进对于组件，用于监听原生事件 //而不是组件使用vm.$emit触发的自定义事件 nativeOn: &#123; click: this.nativeClickHandler &#125;, //自定义指令 directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1+1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], //作用域slot //&#123;name: props =&gt; VNode | Array&lt;Vnode&gt; &#125; scopedSlots: &#123; default: props =&gt; h('span', props.text) &#125;, //如果子组件有定义slot的名称 slot: 'name-of-slot', //其他特殊顶层属性 key: 'myKey', ref: 'myRef'&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-从入门到放弃]]></title>
    <url>%2F2019%2F06%2F07%2Fwebpack1%2F</url>
    <content type="text"><![CDATA[webpack出了很久，碍于工作原因一直没有机会使用，近期有时间，就来学习一样。 概念 what 模块打包机 分析项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用 在3.0出现后，Webpack还肩负起了优化项目的责任。 打包：可以把多个Javascript文件打包成一个文件，减少服务器压力和下载带宽。 转换：把拓展语言转换成为普通的JavaScript，让浏览器顺利运行。 优化：前端变的越来越复杂后，性能也会遇到问题，而WebPack也开始肩负起了优化和提升性能的责任。 why-前端为什么要使用webpack 前端技术发展，代码越来越复杂，经常需要依赖一些依赖包或拓展语言，如less\sass等，使用webpack打包工具，可以有效的帮助我们编译这些依赖包语法，适应于浏览器。 安装 全局安装（不推荐） 1npm install -g webpack 缺点： 会将您项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。 假如一开始全局安装2的版本，新建项目用的3的版本，这样项目就会构建失败。 项目目录安装 新建目录 初始化 npm init 生成package.json文件 可以直接生成以后在package.json文件中修改配置 安装webpack 1npm install --save-dev webpack - --save-dev（保存在开发版本中） –save （保存在生产环境中） 安装webpack cli（3.0+） npm i webpack-cli -D npm i -D 是 npm install –save-dev 的简写 安装失败 检查node的版本号是否过低（node -v） 网络问题，可以考虑使用cnpm来安装（这个是淘宝实时更新的镜像）,具体可以登录cnpm的官方网站学习http://npm.taobao.org/。 权限问题，在Liux、Mac安装是需要权限，如果你是Windows系统，主要要使用以管理员方式安装。 查看版本 npm webpack -v webpack -v（安装的有webpack cli) 使用 终端打包（不常用） 项目结构 项目中准备src文件夹和dist文件夹 src文件夹：用来存放我们编写的javascript代码，即原始的开发代码。 dist文件夹：用来存放供浏览器读取的文件，这个是webpack打包生成的文件。 打包 3.0+ webpack src/index.js dist/index.bundle.js 4.0+ webpack src/index.js -o dist/index.bundle.js 配置文件打包（多入口多出口） 项目结构 项目中准备src文件夹、dist文件夹、webpack.config.js文件 src文件夹：用来存放我们编写的javascript代码，即原始的开发代码。 dist文件夹：用来存放供浏览器读取的文件，这个是webpack打包生成的文件。 webpack.config.js文件：webpack配置文件 webpack.config.js 定义path 1const path = require('path'); module.exports：暴露 entry：{入口} name：’url’ name为自定义参数名 对应出口的[name] output：{出口} path：path.resolve(__dirname,’dist’) node的语法，代表dist文件夹路径 filename：’[name].js’ name表示和打包前文件名字一样 module：{模块，主要是解析CSS和图片转换压缩等功能} plugins：[插件,用于生产模版和各项功能] devServer：{服务} 运行 终端输入webpack即可打包 服务与热更新 作用 便于修改保存代码后，页面直接能刷新显示修改项 无需重新打包等 配置 在webpack.config.js中对devServer选项进行配置 contentBase：配置服务器基本运行路径，用于找到程序打包地址。path.resolve(__dirname,’dist’) 如果不设置，则默认是项目的目录 dist表示运行的目录文件夹名 host：服务运行地址，建议使用本机IP 默认为localhost compress：服务器端压缩选型，一般设置为开启，如果你对服务器压缩感兴趣，可以自行学习。 port：服务运行端口，建议不使用80，很容易被占用，这里使用了1717 historyApiFallback：返回404页面时重定向 rewrites:[ {from:/./,to:’/404.html’} ] overlay：编译出错时在页面上显示错误 默认为false 安装 1npm install webpack-dev-server --save-dev 运行 node_modules/.bin/webpack-dev-server 打开浏览器，进入localhose:8080 ![img](file:///C:/Users/49121/Documents/My Knowledge/temp/12236fbf-e361-497d-a5b5-ded3b49d4966/128/index_files/0.8036843433224872.png) 停止运行 ctrl+c Loaders 功能 通过使用不同的Loader，Webpack可以的脚本和工具，从而对不同的文件格式进行特定处理。 如将SASS文件转换成CSS，ES6代码转化成浏览器能兼容的JS代码，JSX转化成JS 安装 所有的Loaders都需要在npm中单独进行安装，并在webpack.config.js里进行配置。 配置 test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的； use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错； include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） CSS打包 安装 style-loader 1npm install style-loader --save-dev css-loader 1npm install css-loader --save-dev 使用 在js中引入css import css from ‘./css/common.css’; require(‘./css/common.css’); 在webpack.config.js中的module属性中进行配置（3种写法） 对于css文件，先使用css-loader转换，再通过style-loader转换 use可以为对象或数组，当为数组时，它的编译顺序从后往前。 ![img](file:///C:/Users/49121/Documents/My Knowledge/temp/12236fbf-e361-497d-a5b5-ded3b49d4966/128/index_files/0.5625951723091596.png) ![img](file:///C:/Users/49121/Documents/My Knowledge/temp/12236fbf-e361-497d-a5b5-ded3b49d4966/128/index_files/0.9726869001118543.png) ![img](file:///C:/Users/49121/Documents/My Knowledge/temp/12236fbf-e361-497d-a5b5-ded3b49d4966/128/index_files/0.7879023006304329.png) CSS提取（看情况使用） 插件 extract-text-webpack-plugin 安装 1npm install extract-text-webpack-plugin -D 使用 引入 在webpack.config.js中require引入 1const extractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;); - ### 配置 - webpack.config.js中plugins中配置 - new extractTextPlugin(&apos;/css/index.css&apos;) - 这里的/css/index.css是分离后的路径位置。 - 修改webpack.config.js中modules里css文件打包的配置 ![img](file:///C:/Users/49121/Documents/My Knowledge/temp/12236fbf-e361-497d-a5b5-ded3b49d4966/128/index_files/0.19871031393429295.png) - extractTextPlugin.extract(options:loader|object) - options.use:指需要什么样的loader去编译文件 - options.fallback:编译后用什么loader来提取css文件 - options.publicfile:用来覆盖项目路径,生成该css文件的文件路径 注意 如果css分离路径不对，则可以使用publicPath解决 publicPath：output选项，用于处理静态文件路径 写法：“http: //devServer配置的IP和端口/” 优点：加快速度 JS压缩 uglifyjs-webpack-glugin插件 引入 1const uglify = require('uglifyjs-webpack-plugin'); plugins : [ new uglify()] webpack4+好像已经自动调用了？ HTML打包 位置 src文件夹下，无需引入js文件 插件 html-webpack-plugin 安装 1npm install html-webpacl-plugin --save-dev 引入 webpack.config.js中先引入插件 1const htmlPlugin= `require`('html-webpack-plugin'); - ### 在plugins中配置 ![img](file:///C:/Users/49121/Documents/My Knowledge/temp/12236fbf-e361-497d-a5b5-ded3b49d4966/128/index_files/0.992537507561658.png) - minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。 - hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。 - template：是要打包的html模版路径和文件名称。 图片处理 位置 src/images 插件 url-loader 如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。 file-loader 解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。 安装 1npm install file-loader url-loader --save-dev loader不需要引入 配置 在modules中配置 ![img](file:///C:/Users/49121/Documents/My Knowledge/temp/12236fbf-e361-497d-a5b5-ded3b49d4966/128/index_files/0.855049943065711.png) test:/.(png|jpg|gif)/是匹配图片文件后缀名称。 use：是指定使用的loader和loader的配置参数。 limit：是把小于500000B的文件打成Base64的格式，写入JS。 outputPath：输出路径 注意 url-loader封装了file-loader，且不依赖于file-loader，使用url-loader时，只需要安装url-loader即可。 此处安装file-loader只是便于后期使用 1.文件大小小于limit参数，url-loader将会把文件转为DataURL（Base64格式）； 2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。 html中的图片处理 loader html-loader 安装 1npm install html-withimg-loader --save-dev 配置 在modules中配置test和use LESS、SASS配置 LESS 安装 1npm install less -D 【less安装包 1npm install less-loader -D 【less-loader 配置 webpack.config.js中的modules中配置 ![img](file:///C:/Users/49121/Documents/My Knowledge/temp/12236fbf-e361-497d-a5b5-ded3b49d4966/128/index_files/0.8031091758987152.png) 编写一个less文件 引入到js文件中 1import less from './css/black.less'; 参考资料：技术胖：Webpack3.X版 成神之路 (共24集)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
